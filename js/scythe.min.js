//@prepros-append _init.js
//@prepros-append utils.js

//@prepros-append game/index.js
//@prepros-append ui/index.js

//@prepros-append init.js

//@prepros-append _end.js
;(function(){
	"use strict";

	var log = console.log;


var capitalize = function(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
};

var extendObject = function () {
	var extended = {};

	// Merge the object into the extended object
	var merge = function (obj) {
    for ( var prop in obj ) {
      if (obj.hasOwnProperty(prop)) {
        if (Object.prototype.toString.call(obj[prop]) === '[object Object]') {
          // If we're doing a deep merge and the property is an object
          extended[prop] = extendObject(extended[prop], obj[prop]);
        } else {
          // Otherwise, do a regular merge
          extended[prop] = obj[prop];
        }
      }
    }
	};

	// Loop through each object and conduct a merge
	for (var i = 0; i < arguments.length; i++) {
		merge(arguments[i]);
	}

	return extended;
};

var cloneObject = function (orig) {
  // var destiny = {};
  // for (var prop in orig) {
  //   if (orig.hasOwnProperty(prop)) {
  //     destiny[prop] = orig[prop];
  //   }
  // }
  // return destiny;
  return extendObject({},orig);
};

var isOdd = function (num) {
  return num % 2;
};
/* GAME API **************/
var GAME = null;

var GAMECONFIG = {
	factions: [{
		name: 'rusviet',
		power: 3,
		cards: 2
	}, {
		name: 'togawa',
		power: 0,
		cards: 2
	}, {
		name: 'crimean',
		power: 5,
		cards: 0
	}, {
		name: 'saxony',
		power: 1,
		cards: 4
	}, {
		name: 'polania',
		power: 2,
		cards: 3
	}, {
		name: 'albion',
		power: 3,
		cards: 0
	}, {
		name: 'nordic',
		power: 4,
		cards: 1
	}],
	playerTypes: [{
		name: 'None',
		ai: false,
		icon: ''
	},{
		name: 'Human',
		ai: false,
		icon: 'fa fa-user-o'
	}, {
		name: 'Autometta',
		ai: true,
		level: 'Easy',
		icon: 'fa fa-cogs',
		crossRiver: false,
		strategy: 1,
		step: 0,
		timeline: [{}, {}, {}, {}, {}, {
			crossRiver: true
		}, {}, {}, {}, {}, {
			changeEstrategy: true,
			star: true
		}, {}, {}, {}, {}, {
			star: true
		}, {}, {}, {
			star: true
		}, {}, {
			star: true
		}, {}, {
			star: true
		}, {
			star: true
		}]
	}, {
		name: 'Automa',
		ai: true,
		level: 'Normal',
		icon: 'fa fa-cogs',
		crossRiver: false,
		strategy: 1,
		step: 0,
		timeline: [{}, {}, {}, {}, {
			crossRiver: true
		}, {}, {}, {}, {}, {
			changeEstrategy: true,
			star: true
		}, {}, {}, {}, {}, {
			star: true
		}, {}, {}, {
			star: true
		}, {}, {
			star: true
		}, {
			star: true
		}, {
			star: true
		}]
	}, {
		name: 'Automaszyna',
		ai: true,
		level: 'Hard',
		icon: 'fa fa-cogs',
		crossRiver: false,
		strategy: 1,
		step: 0,
		timeline: [{}, {}, {}, {
			crossRiver: true
		}, {}, {}, {}, {}, {}, {
			changeEstrategy: true,
			star: true
		}, {}, {}, {
			star: true
		}, {}, {
			star: true
		}, {}, {
			star: true
		}, {
			star: true
		}, {
			star: true
		}]
	}, {
		name: 'Ultimaszyna',
		ai: true,
		level: 'Very hard',
		icon: 'fa fa-cogs',
		crossRiver: true,
		strategy: 1,
		step:0,
		timeline: [{
			crossRiver: true
		}, {}, {}, {}, {}, {}, {}, {}, {
			changeEstrategy: true,
			star: true
		}, {}, {}, {
			star: true
		}, {}, {
			star: true
		}, {}, {
			star: true
		}, {
			star: true
		}, {
			star: true
		}]
	}]
};

/* CREATE GAME **************************************/
var createGame = function(factionToCreate) {
		var G = {};

G.aiResources = 0;

// Create Players
var players = [],
	currentPlayerIndex = -1;

factionToCreate.forEach(function(facInd, i){
	if(facInd > 0){
		var player = cloneObject(GAMECONFIG.playerTypes[facInd]),
			faction = GAMECONFIG.factions[i];

		player.factionName = faction.name;
		player.power = faction.power;
		player.cards = faction.cards;
		player.money = 0;
		player.board = {
			'worker': 6,
			'mech': 4,
			'stars': 6,
			'starsByWar': 2,
			'starsByPower': 1,
			'factoryCard':false
		};

		players.push(player);

		// Choose a Human player to start
		//		if(!player.ai){
		//
		if (player.ai) {
			currentPlayerIndex = players.length - 1;
		} 
	}
});

G.players = function(){
	return players;
};

G.getCurrentPlayer = function(){
	return players[currentPlayerIndex];
};
G.advancePlayer = function(){
	currentPlayerIndex = currentPlayerIndex >= (players.length - 1) ? 0 : currentPlayerIndex + 1;
};

G.getPlayerByFaction = function(faction){
	var pl = null;
	players.forEach(function(p){
		if(p.factionName === faction){
			pl = p;
		}
	});
	return pl;
};

G.combatBetweenAIs = function(player1,player2){	
	var card1 = getCard(),
		card2 = getCard(),
		sec1 = 0,
		sec2 = 0;

	if(player1.power <= 7){
		sec1 = 0;
	}else if(player1.power >= 14){
		sec1 = 2;
	}else{
		sec1 = 1;
	}
	var power1 = card1.combat.power[sec1];
	power1 = player1.power < power1 ? player1.power : power1;

	if(player2.power <= 7){
		sec2 = 0;
	}else if(player2.power >= 14){
		sec2 = 2;
	}else{
		sec2 = 1;
	}
	var power2 = card2.combat.power[sec2];
	power2 = player2.power < power2 ? player2.power : power2;

	G.getPlayerByFaction(player1.factionName).power -= power1;
	G.getPlayerByFaction(player2.factionName).power -= power2;

	return {
		player1:{
			winner: power1 >= power2,
			reduce: power1
		},
		player2:{
			winner: power1 < power2,
			reduce: power2
		}
	};
};

G.MAP = {
	'12': {
		'num': 12,
		'type': 'head',
		'factionHead': 'albion',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': 'albion',
		'attack': null, 'distance': 4
	},
	'15': {
		'num': 15,
		'type': 'head',
		'factionHead': 'nordic',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': 'nordic',
		'attack': null, 'distance': 4
	},
	'22': {
		'num': 22,
		'type': 'iron',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 4
	},
	'23': {
		'num': 23,
		'type': 'farm',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	// '23': {
	// 	'num': 23,
	// 	'type': 'farm',
	// 	'people': {
	// 		'worker': 2,
	// 		'mech': 0,
	// 		'character': 0
	// 	},
	// 	'faction': 'rusviet',
	// 	'attack': {
	// 		'faction': 'crimean',
	// 		'mech': 2
	// 	},
	// 	'distance': 3
	// },
	'24': {
		'num': 24,
		'type': 'aldea',
		'encounter': true,
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	// '24': {
	// 	'num': 24,
	// 	'type': 'aldea',
	// 	'encounter': true,
	// 	'people': {
	// 		'worker': 0,
	// 		'mech': 1,
	// 		'character': 0
	// 	},
	// 	'faction': 'rusviet',
	// 	'attack': {
	// 		'faction': 'crimean',
	// 		'mech': 2
	// 	},'distance': 3
	// },
	'25': {
		'num': 25,
		'type': 'wood',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 1
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	// '25': {
	// 	'encounter':true,
	// 	'num': 25,
	// 	'type': 'wood',
	// 	'people': {
	// 		'worker': 0,
	// 		'mech': 1,
	// 		'character': 0
	// 	},
	// 	'faction': 'rusviet',
	// 	'attack': {
	// 		'faction': 'crimean',
	// 		'character': 1
	// 	},'distance': 3
	// },
	'26': {
		'num': 26,
		'type': 'oil',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	// '26': {
	// 	'num': 26,
	// 	'type': 'oil',
	// 	'people': {
	// 		'worker': 0,
	// 		'mech': 2,
	// 		'character': 0
	// 	},
	// 	'faction': 'rusviet',
	// 	'attack': {
	// 		'faction': 'crimean',
	// 		'mech': 2
	// 	},'distance': 3
	// },
	'27': {
		'num': 27,
		'type': 'aldea',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 4
	},
	// '27': {
	// 	'num': 27,
	// 	'type': 'aldea',
	// 	'people': {
	// 		'worker': 3,
	// 		'mech': 0,
	// 		'character': 0
	// 	},
	// 	'faction': 'rusviet',
	// 	'attack': {
	// 		'faction': 'crimean',
	// 		'mech': 2
	// 	},'distance': 4
	// },
	'31': {
		'num': 31,
		'type': 'lake',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 4
	},
	'32': {
		'num': 32,
		'type': 'oil',
		'encounter': true,
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	'33': {
		'num': 33,
		'type': 'lake',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 2
	},
	'34': {
		'num': 34,
		'type': 'oil',
		'tunnel': true,
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 2
	},
	'35': {
		'num': 35,
		'type': 'iron',
		//'encounter': true,
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 1
		},
		'faction': 'crimean',
		'attack': null, 'distance': 2
	},
	'36': {
		'num': 36,
		'type': 'farm',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	'37': {
		'num': 37,
		'type': 'farm',
		'encounter': true,
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 4
	},
	'41': {
		'num': 41,
		'type': 'head',
		'factionHead': 'polania',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': 'polania',
		'attack': null, 'distance': 4
	},
	'42': {
		'num': 42,
		'type': 'wood',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	'43': {
		'num': 43,
		'type': 'iron',
		'tunnel': true,
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 2
	},
	'44': {
		'num': 44,
		'type': 'wood',
		'people': {
			'worker': 0,
			'mech': 1,
			'character': 0
		},
		'faction': 'crimean',
		'attack': null, 'distance': 1
	},
	'45': {
		'num': 45,
		'type': 'lake',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 1
	},
	'46': {
		'num': 46,
		'type': 'wood',
		'tunnel': true,
		'people': {
			'worker': 0,
			'mech': 1,
			'character': 0
		},
		'faction': 'rusviet',
		'attack': null, 'distance': 2
	},
	'47': {
		'num': 47,
		'type': 'aldea',
		'people': {
			'worker': 1,
			'mech': 1,
			'character': 0
		},
		'faction': 'rusviet',
		'attack': null, 'distance': 3
	},
	'48': {
		'num': 48,
		'type': 'head',
		'factionHead': 'rusviet',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': 'rusviet',
		'attack': null, 'distance': 4
	},
	'51': {
		'num': 51,
		'type': 'farm',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	'52': {
		'num': 52,
		'type': 'aldea',
		'encounter': true,
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 2
	},
	'53': {
		'num': 53,
		'type': 'lake',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 1
	},
	'54': {
		'num': 54,
		'type': 'factory',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 0
	},
	'55': {
		'num': 55,
		'type': 'iron',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 1
		},
		'faction': 'rusviet',
		'attack': null, 'distance': 1
	},
	'56': {
		'num': 56,
		'type': 'oil',
		'encounter': true,
		'people': {
			'worker': 1,
			'mech': 0,
			'character': 0
		},
		'faction': 'rusviet',
		'attack': null, 'distance': 2
	},
	'57': {
		'num': 57,
		'type': 'iron',
		'people': {
			'worker': 1,
			'mech': 0,
			'character': 0
		},
		'faction': 'rusviet',
		'attack': null, 'distance': 3
	},
	'61': {
		'num': 61,
		'type': 'wood',
		'encounter': true,
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 4
	},
	'62': {
		'num': 62,
		'type': 'wood',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	'63': {
		'num': 63,
		'type': 'farm',
		'tunnel': true,
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 2
	},
	'64': {
		'num': 64,
		'type': 'oil',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 1
	},
	'65': {
		'num': 65,
		'type': 'lake',
		'people': {
			'worker': 2,
			'mech': 0,
			'character': 0
		},
		'faction': 'crimean',
		'attack': null, 'distance': 1
	},
	'66': {
		'num': 66,
		'type': 'aldea',
		'tunnel': true,
		'people': {
			'worker': 1,
			'mech': 1,
			'character': 0
		},
		'faction': 'rusviet',
		'attack': null, 'distance': 2
	},
	'67': {
		'num': 67,
		'type': 'lake',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	'71': {
		'num': 71,
		'type': 'iron',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 4
	},
	'72': {
		'num': 72,
		'type': 'aldea',
		'encounter': true,
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	'73': {
		'num': 73,
		'type': 'aldea',
		'encounter': true,
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 2
	},
	'74': {
		'num': 74,
		'type': 'oil',
		'tunnel': true,
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 2
	},
	'75': {
		'num': 75,
		'type': 'wood',
		'people': {
			'worker': 1,
			'mech': 0,
			'character': 0
		},
		'faction': 'crimean',
		'attack': null, 'distance': 2
	},
	'76': {
		'num': 76,
		'type': 'iron',
		'encounter': true,
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	'77': {
		'num': 77,
		'type': 'oil',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 4
	},
	'81': {
		'num': 81,
		'type': 'head',
		'factionHead': 'saxony',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': 'saxony',
		'attack': null, 'distance': 5
	},
	'82': {
		'num': 82,
		'type': 'oil',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 4
	},
	'83': {
		'num': 83,
		'type': 'lake',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	'84': {
		'num': 84,
		'type': 'farm',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	'85': {
		'num': 85,
		'type': 'iron',
		'encounter': true,
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	'86': {
		'num': 86,
		'type': 'aldea',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 3
	},
	'87': {
		'num': 87,
		'type': 'farm',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 4
	},
	'88': {
		'num': 88,
		'type': 'head',
		'factionHead': 'togawa',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': 'togawa',
		'attack': null, 'distance': 5
	},
	'93': {
		'num': 93,
		'type': 'head',
		'factionHead': 'crimean',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': 'crimean',
		'attack': null, 'distance': 4
	},
	'94': {
		'num': 94,
		'type': 'aldea',
		'people': {
			'worker': 0,
			'mech': 0,
			'character': 0
		},
		'faction': null,
		'attack': null, 'distance': 4
	}
};

// init Map
var initialMap = {
	'rusviet': [48, 47, 57],
	'togawa': [88, 87, 77],
	'crimean': [93, 84, 94],
	'saxony': [81, 82, 71],
	'polania': [41, 42, 51],
	'albion': [12, 22, 23],
	'nordic': [15, 25, 26],
};
// players.forEach(function (pl) {

// 	var fact = pl.factionName;
// 	var inMap = initialMap[fact];

// 	G.MAP[inMap[0]].faction = fact;
// 	G.MAP[inMap[0]].people.character = 1;

// 	G.MAP[inMap[1]].faction = fact;
// 	G.MAP[inMap[1]].people.worker = 1;

// 	G.MAP[inMap[2]].faction = fact;
// 	G.MAP[inMap[2]].people.worker = 1;
// 	G.MAP[inMap[2]].people.mech = 1;
// });

G.notCrossRiverHexNum = {
	'rusviet': '48-47-56-57',	
	'crimean': '93-94-84-85',
	'saxony': '81-71-72-82',
	'polania': '41-42-51-52',	
	'nordic': '15-25-26-35',
	'togawa': '88-22-23-32-43-44-34-54-55-46-36-37-27-64-74-73-63-62-61-66-75-76-86-77-87',
	'albion': '12-22-23-32-43-44-34-54-55-46-36-37-27-64-74-73-63-62-61-66-75-76-86-77-87'
};

G.getBaseMapIndex = function (factionName) {
	return initialMap[factionName][0];
};

G.hexConflict = {
	workers: [],
	war: null
};

G.evaluateEncounter = function () {
	var hex = null;

	for (var a in G.MAP) {
		var h = G.MAP[a];
		if (h.encounter) {
			if (h.people.character > 0) {
				hex = h;
			} 
		}
	}
	return hex;
};

G.evaluateAttack = function () {
	var hexs = {
		workers: [],
		war: null
	};

	for (var a in G.MAP) {
		var h = cloneObject(G.MAP[a]);
		if (h.attack) {
			if (h.people.mech === 0 && h.people.character === 0) {
				hexs.workers.push(h);
			} else {
				hexs.war = h;
			}
		}
	}
	return hexs;
};
/* DECK ***************/
var getCard = (function () {
	var originalDeck = [
		{
			'num': 1,
			'e1': {
				'move': [{
					'type': 'worker',
					'faction': 'nordic'
				}, {
					'type': 'encounter_or_factory'
				}, {
					'type': 'character'
				}],
				'gain': [{
					'type': 'power'
				}, {
					'type': 'worker'
				}],
				'recruit': 'power'
			},
			'e2': {
				'move': [{
					'type': 'worker'
				}],
				'gain': [{
					'type': 'power',
					'count': 4
				}],
				'recruit': 'power'
			},
			'advance': true,
			'combat': {
				'power': [6, 7, 7],
				'cards': 1
			},
			'resources': 1
		}, {
			'num': 2,
			'e1': {
				'move': [{
					'type': 'encounter_or_factory',
					'faction': 'polania'
				}, {
					'type': 'worker'
				}],
				'gain': [{
					'type': 'money',
					'faction': 'crimean'
				}, {
					'type': 'money'
				}],
				'recruit': null
			},
			'e2': {
				'move': [{
					'type': 'encounter_or_factory',
					'faction': 'polania'
				}, {
					'type': 'worker'
				}],
				'gain': [{
					'type': 'money',
					'faction': 'crimean'
				}, {
					'type': 'card'
				}, {
					'type': 'mech'
				}],
				'recruit': 'money'
			},
			'advance': true,
			'combat': {
				'power': [5, 6, 7],
				'cards': 2
			},
			'resources': 2
		}, {
			'num': 3,
			'e1': {
				'move': [{
					'type': 'worker'
				}],
				'gain': [{
					'type': 'power',
					'count': 3
				}],
				'recruit': null
			},
			'e2': {
				'move': [{
					'type': 'worker'
				}],
				'gain': [{
					'type': 'power',
					'count': 2
				}, {
					'type': 'worker'
				}],
				'recruit': 'popularity'
			},
			'advance': true,
			'combat': {
				'power': [3, 7, 7],
				'cards': 0
			},
			'resources': 0
		}, {
			'num': 4,
			'notAutometta': true,
			'e1': {
				'move': [{
					'type': 'worker'
				}],
				'gain': [{
					'type': 'money',
					'faction': 'crimean'
				}, {
					'type': 'card'
				}],
				'recruit': 'card'
			},
			'e2': {
				'move': [{
					'type': 'worker'
				}],
				'gain': [{
					'type': 'money',
					'faction': 'crimean'
				}, {
					'type': 'money',
					'count': 2
				}],
				'recruit': 'power'
			},
			'advance': false,
			'combat': {
				'power': [0, 1, 2],
				'cards': 1
			},
			'resources': 0
		}, {
			'num': 5,
			'e1': {
				'move': [{
					'type': 'encounter_or_factory',
					'faction': 'albion'
				}, {
					'type': 'worker'
				}],
				'gain': [{
					'type': 'mech',
					'faction': 'togawa'
				}, {
					'type': 'worker'
				}, {
					'type': 'money'
				}],
				'recruit': 'money'
			},
			'e2': {
				'move': [{
					'type': 'mech'
				}],
				'gain': [{
					'type': 'power',
					'count': 4
				}, {
					'type': 'worker'
				}],
				'recruit': 'card'
			},
			'advance': true,
			'combat': {
				'power': [2, 4, 7],
				'cards': 1
			},
			'resources': 4
		}, {
			'num': 6,
			'e1': {
				'move': [{
					'type': 'worker'
				}],
				'gain': [{
					'type': 'power',
					'count': 2
				}],
				'recruit': null
			},
			'e2': {
				'move': [{
					'type': 'mech'
				}],
				'gain': [{
					'type': 'money',
					'faction': 'crimean'
				}, {
					'type': 'power',
					'count': 2
				}, {
					'type': 'mech'
				}],
				'recruit': 'power'
			},
			'advance': true,
			'combat': {
				'power': [7, 7, 7],
				'cards': 1
			},
			'resources': 0
		}, {
			'num': 7,
			'notAutometta': true,
			'e1': {
				'move': [{
					'attack': 5,
					'type': 'character_or_mech',
					'faction': 'saxony'
				}, {
					'type': 'worker'
				}],
				'gain': [{
					'type': 'worker'
				}, {
					'type': 'money'
				}],
				'recruit': 'popularity'
			},
			'e2': {
				'move': [{
					'attack': 5,
					'type': 'character_or_mech',
					'faction': 'saxony'
				}, {
					'type': 'mech'
				}],
				'gain': [{
					'type': 'mech',
					'faction': 'rusviet'
				}, {
					'type': 'mech'
				}, {
					'type': 'card'
				}],
				'recruit': 'money'
			},
			'advance': true,
			'combat': {
				'power': [5, 7, 7],
				'cards': 0
			},
			'resources': 2
		}, {
			'num': 8,
			'notAutometta': true,
			'e1': {
				'move': [{
					'type': 'encounter_or_factory',
					'faction': 'togawa'
				}, {
					'type': 'mech'
				}, {
					'type': 'worker'
				}],
				'gain': [{
					'type': 'mech',
					'faction': 'togawa'
				}, {
					'type': 'mech'
				}],
				'recruit': null
			},
			'e2': {
				'move': [{
					'type': 'encounter_or_factory',
					'faction': 'togawa'
				}, {
					'type': 'mech'
				}],
				'gain': [{
					'type': 'power',
					'faction': 'saxony'
				}, {
					'type': 'money'
				}, {
					'type': 'mech'
				}],
				'recruit': 'money'
			},
			'advance': true,
			'combat': {
				'power': [0, 7, 7],
				'cards': 2
			},
			'resources': 1
		}, {
			'num': 9,
			'e1': {
				'move': [{
					'type': 'encounter_or_factory',
					'faction': 'polania'
				}, {
					'type': 'mech'
				}, {
					'type': 'worker'
				}],
				'gain': [{
					'type': 'worker'
				}, {
					'type': 'mech'
				}],
				'recruit': 'popularity'
			},
			'e2': {
				'move': [{
					'type': 'encounter_or_factory',
					'faction': 'polania'
				}, {
					'type': 'mech'
				}],
				'gain': [{
					'type': 'power',
					'count': 3
				}, {
					'type': 'worker'
				}],
				'recruit': 'popularity'
			},
			'advance': true,
			'combat': {
				'power': [4, 7, 7],
				'cards': 1
			},
			'resources': 3
		}, {
			'num': 10,
			'e1': {
				'move': [{
					'type': 'mech'
				}, {
					'type': 'worker'
				}],
				'gain': [{
					'type': 'mech'
				}, {
					'type': 'power',
					'count': 2
				}],
				'recruit': null
			},
			'e2': {
				'move': [{
					'type': 'mech'
				}],
				'gain': [{
					'type': 'money',
					'count': 2
				}, {
					'type': 'mech'
				}],
				'recruit': null
			},
			'advance': true,
			'combat': {
				'power': [0, 0, 0],
				'cards': 1
			},
			'resources': 1
		}, {
			'num': 11,
			'e1': {
				'move': [{
					'type': 'mech'
				}, {
					'type': 'encounter_or_factory'
				}, {
					'type': 'character'
				}],
				'gain': [{
					'type': 'worker',
					'faction': 'rusviet'
				}, {
					'type': 'worker'
				}, {
					'type': 'money'
				}],
				'recruit': null
			},
			'e2': {
				'move': [{
					'type': 'worker',
					'faction': 'nordic'
				}, {
					'type': 'encounter_or_factory'
				}, {
					'type': 'character'
				}],
				'gain': [{
					'type': 'power',
					'count': 3
				}, {
					'type': 'worker'
				}],
				'recruit': 'card'
			},
			'advance': true,
			'combat': {
				'power': [6, 7, 7],
				'cards': 2
			},
			'resources': 0
		}, {
			'num': 12,
			'e1': {
				'move': [{
					'type': 'worker',
					'faction': 'nordic'
				}, {
					'type': 'mech'
				}],
				'gain': [{
					'type': 'power',
					'count': 4
				}],
				'recruit': null
			},
			'e2': {
				'move': [{
					'type': 'worker',
					'faction': 'nordic'
				}, {
					'type': 'mech'
				}],
				'gain': [{
					'type': 'worker'
				}, {
					'type': 'money'
				}, {
					'type': 'mech'
				}],
				'recruit': 'power'
			},
			'advance': true,
			'combat': {
				'power': [4, 5, 7],
				'cards': 2
			},
			'resources': 1
		}, {
			'num': 13,
			'e1': {
				'move': [{
					'attack': 4,
					'type': 'character_or_mech',
					'faction': 'saxony'
				}, {
					'type': 'encounter_or_factory'
				}, {
					'type': 'character'
				}],
				'gain': [{
					'type': 'money'
				}],
				'recruit': null
			},
			'e2': {
				'move': [{
					'attack': 5,
					'type': 'character_or_mech',
					'faction': 'saxony'
				}, {
					'type': 'encounter_or_factory'
				}, {
					'type': 'character'
				}],
				'gain': [{
					'type': 'card'
				}, {
					'type': 'money',
					'count': 2
				}],
				'recruit': 'money'
			},
			'advance': true,
			'combat': {
				'power': [3, 5, 7],
				'cards': 3
			},
			'resources': 0
		}, {
			'num': 14,
			'e1': {
				'move': [{
					'type': 'encounter_or_factory'
				}, {
					'type': 'character'
				}],
				'gain': [{
					'type': 'worker'
				}, {
					'type': 'card'
				}],
				'recruit': 'card'
			},
			'e2': {
				'move': [{
					'attack': 7,
					'type': 'character_or_mech'
				}, {
					'attack': 'worker',
					'type': 'worker_attack'
				}, {
					'type': 'mech'
				}],
				'gain': [{
					'type': 'power',
					'count': 3
				}],
				'recruit': 'popularity'
			},
			'advance': true,
			'combat': {
				'power': [1, 1, 1],
				'cards': 1
			},
			'resources': 0
		}, {
			'num': 15,
			'e1': {
				'move': [{
					'type': 'encounter_or_factory'
				}, {
					'type': 'character'
				}],
				'gain': [{
					'type': 'power',
					'count': 3
				}, {
					'type': 'money'
				}],
				'recruit': 'money'
			},
			'e2': {
				'move': [{
					'attack': 1,
					'type': 'character_or_mech'
				}, {
					'attack': 'worker',
					'type': 'worker_attack'
				}, {
					'type': 'encounter_or_factory'
				}, {
					'type': 'character'
				}],
				'gain': [{
					'type': 'money',
					'faction': 'crimean'
				}, {
					'type': 'money',
					'faction': 'crimean'
				}],
				'recruit': 'card'
			},
			'advance': false,
			'combat': {
				'power': [7, 7, 7],
				'cards': 0
			},
			'resources': 2
		}, {
			'num': 16,
			'e1': {
				'move': [{
					'type': 'encounter_or_factory'
				}, {
					'type': 'character'
				}],
				'gain': [{
					'type': 'mech'
				}],
				'recruit': null
			},
			'e2': {
				'move': [{
					'attack': 5,
					'type': 'character_or_mech'
				}, {
					'attack': 'worker',
					'type': 'worker_attack'
				}, {
					'type': 'mech'
				}],
				'gain': [{
					'type': 'power',
					'faction': 'saxony'
				}, {
					'type': 'mech'
				}, {
					'type': 'money'
				}],
				'recruit': null
			},
			'advance': true,
			'combat': {
				'power': [5, 7, 7],
				'cards': 1
			},
			'resources': 4
		}, {
			'num': 17,
			'notAutometta': true,
			'e1': {
				'move': [{
					'attack': 6,
					'type': 'character_or_mech'
				}, {
					'attack': 'worker',
					'type': 'worker_attack'
				}, {
					'type': 'worker'
				}],
				'gain': [{
					'type': 'money',
					'count': 2
				}],
				'recruit': 'power'
			},
			'e2': {
				'move': [{
					'attack': 8,
					'type': 'character_or_mech'
				}, {
					'type': 'worker'
				}],
				'gain': [{
					'type': 'money',
					'faction': 'crimean'
				}, {
					'type': 'money'
				}, {
					'type': 'worker'
				}],
				'recruit': 'popularity'
			},
			'advance': false,
			'combat': {
				'power': [7, 7, 7],
				'cards': 2
			},
			'resources': 2
		}, {
			'num': 18,
			'e1': {
				'move': [{
					'type': 'encounter_or_factory'
				}, {
					'type': 'character'
				}],
				'gain': [{
					'type': 'worker',
					'faction': 'albion'
				}, {
					'type': 'worker'
				}, {
					'type': 'money'
				}],
				'recruit': null
			},
			'e2': {
				'move': [{
					'type': 'encounter_or_factory'
				}, {
					'type': 'character'
				}],
				'gain': [{
					'type': 'mech',
					'faction': 'albion'
				}, {
					'type': 'worker'
				}, {
					'type': 'money',
					'count': 2
				}],
				'recruit': null
			},
			'advance': true,
			'combat': {
				'power': [1, 1, 7],
				'cards': 0
			},
			'resources': 1
		}, {
			'num': 19,
			'e1': {
				'move': [{
					'attack': 'worker',
					'type': 'worker_attack'
				}, {
					'type': 'worker'
				}],
				'gain': [{
					'type': 'worker'
				}],
				'recruit': null
			},
			'e2': {
				'move': [{
					'type': 'encounter_or_factory',
					'faction': 'albion'
				}, {
					'attack': 'worker',
					'type': 'worker_attack'
				}, {
					'type': 'worker'
				}],
				'gain': [{
					'type': 'power',
					'count': 3
				}, {
					'type': 'money'
				}],
				'recruit': 'card'
			},
			'advance': true,
			'combat': {
				'power': [7, 7, 7],
				'cards': 1
			},
			'resources': 1
		}],
		deck = [],
		shuffle = function (o) {
			for (var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
			return o;
		},
		generateDeck = function () {
			deck = shuffle(originalDeck.slice(0));
		};
	return function () {
		if (deck.length === 0) {
			generateDeck();
		}

		var card = deck[0];
		deck.shift();

		//	return card;




		//////////
		// var tt = {};
		// originalDeck.forEach(function(c){
		// 	c.e1.move.forEach(function(m){
		// 		tt[m.type] += m.attack + ',';
		// 	});
		// 	c.e2.move.forEach(function(m){
		// 		tt[m.type] += m.attack + ',';
		// 	});

		// });


		//console.log('tt',tt);

		var merooo = 5;


		//return originalDeck[merooo - 1];
		
		return {
			//'notAutometta':true,
			'num': 1,
			'e1': {
				'move': [
					// {
					// 	'type': 'worker',
					// 	//	'faction': 'nordic'
					// },
					// {
					// 	'type': 'mech',
					// },
					// {
					// 	'type': 'character'
					// },					
					// {
					// 	'type': 'encounter_or_factory'
					// },
					// // Attack
					// {
					// 	'attack': 1,
					// 	'type': 'character_or_mech'
					// },
					{
						'attack': 'worker',
						'type': 'worker_attack'
					}
				],
				'gain': [{
					'type': 'power'
				}, {
					'type': 'worker'
				}],
				'recruit': 'power'
			},
			'advance': true,
			'combat': {
				'power': [6, 7, 7],
				'cards': 1
			},
			'resources': 1
		};







	};
})();
var AUTOMA = (function () {

	var unitTypes = {
			'worker': ['worker'],
			'mech': ['mech'],
			'character': ['character'],
			'encounter_or_factory': ['character'],
			'character_or_mech': ['mech', 'character'],
			'worker_attack': ['mech', 'character'],
		},
		moveAction,
		player,
		moveChoice = null,
		hexagons,
		hexagonsEnemies,
		hexUnit,
		hexDestiny,
		numBase,
		vecHexagons,
		vecHexagonFiltered;

	var selectHexagons = function () {
		hexagons = [];
		for (var a in G.MAP) {
			if (G.MAP[a].faction === player.factionName) {
				hexagons.push(G.MAP[a]);
			}
		}
	};
	var selectHexagonsEnemies = function () {
		hexagonsEnemies = [];
		for (var a in G.MAP) {
			if (G.MAP[a].faction !== null && G.MAP[a].faction !== player.factionName) {
				hexagonsEnemies.push(G.MAP[a]);
			}
		}
	};
	var getDistance = (function () {
		var cache = {};

		return function (num1, num2) {
			if (num1 === num2) {
				return 0;
			} else {
				var n1 = num1 > num2 ? num1 : num2,
					n2 = num1 < num2 ? num1 : num2;
				if (cache[n1 + '-' + n2] !== undefined) {
					return cache[n1 + '-' + n2];
				} else {
					var n = n1,
						n2String = '' + n2,
						row2 = parseInt(n2String.charAt(0), 10),
						col2 = parseInt(n2String.charAt(1), 10);
					var getNear = function () {
						var nString = '' + n,
							row = parseInt(nString.charAt(0), 10),
							col = parseInt(nString.charAt(1), 10),
							nearRow, nearCol;
						if (row2 < row) {
							nearRow = row - 1;
							if (isOdd(row)) {
								if (col2 <= col) {
									nearCol = col;
								} else {
									nearCol = col + 1;
								}
							} else {
								if (col2 >= col) {
									nearCol = col;
								} else {
									nearCol = col - 1;
								}
							}
						} else {
							nearRow = row;
							if (col2 < col) {
								nearCol = col - 1;
							} else if (col2 > col) {
								nearCol = col + 1;
							} else {
								nearCol = col;
							}
						}
						return parseInt(nearRow + '' + nearCol, 10);
					};
					var d = 0;
					while (n !== n2) {
						n = getNear();
						d++;
					}
					cache[n1 + '-' + n2] = d;
					return d;
				}
			}
		};
	})();
	var orderByDistance = function () {
		hexUnit.sort(function (a, b) {
			var dA = getDistance(a.num, numBase);
			var dB = getDistance(b.num, numBase);
			if (dA < dB) {
				return -1;
			} else if (dA > dB) {
				return 1;
			} else {
				return a.num < b.num ? -1 : 1;
			}
		});
		return hexUnit;
	};
	var selectHexUnit = function () {
		hexUnit = [];

		hexagons.forEach(function (h) {
			unitTypes[moveAction.type].forEach(function (opType) {
				if (h.people[opType] > 0) {
					hexUnit.push(h);
				}
			});
		});
		if (hexUnit.length > 0) {
			hexUnit = orderByDistance()[0];
			return hexUnit;
		} else {
			return null;
		}
	};
	var getVecListForHex = function (hex_num) {
		var nString = '' + hex_num,
			row = parseInt(nString.charAt(0), 10),
			hexVecsNum = isOdd(row) ? [
				hex_num - 10,
				hex_num - 9,
				hex_num - 1,
				hex_num + 1,
				hex_num + 10,
				hex_num + 11
			] : [
				hex_num - 11,
				hex_num - 10,
				hex_num - 1,
				hex_num + 1,
				hex_num + 9,
				hex_num + 10
			],
			hexVecs = [];

		hexVecsNum.forEach(function (h) {
			if (G.MAP[h] !== undefined) {
				hexVecs.push(h);
			}
		});

		return hexVecs;
	};
	var selectVecHexagons = function () {
		vecHexagons = [];
		var vecHexNumbers = {};

		hexagons.forEach(function (hex) {
			var vecHex = getVecListForHex(hex.num);
			vecHexNumbers[hex.num] = true;
			vecHex.forEach(function (h) {
				if (player.crossRiver) {
					vecHexNumbers[h] = true;
				} else {
					if (G.notCrossRiverHexNum[player.factionName].indexOf('' + h) >= 0) {
						vecHexNumbers[h] = true;
					}
				}
			});
		});

		for (var n in vecHexNumbers) {
			vecHexagons.push(G.MAP[n]);
		}
	};
	var filterVecHexagonsByMoveType = function () {

		vecHexagonFiltered = [];
		hexDestiny = null;

		var filter = moveAction.type;
		filter += moveAction.attack ? '_attack' : '';


		var mechOrCharacter_No_attack = function () {

			var yesToBaseHex = [],
				notToBaseHex = [];

			// Select enemies
			selectHexagonsEnemies();

			vecHexagons.forEach(function (vecHex) {
				var el = cloneObject(vecHex);
				if (el.num === hexUnit.num) {
					if (el.people.mech > 0) {
						el.people.mech--;
					}
					if (el.people.character > 0) {
						el.people.character--;
					}
				}
				// if not enemies:
				if (el.faction === null || el.faction === player.factionName) {
					if (el.people.mech === 0 && el.people.character === 0) {
						el.distanceToEnemie = 9999;
						el.toBase = false;

						// Find the closer enemie
						hexagonsEnemies.forEach(function (hexEnem) {
							// if enemies
							if (hexEnem.people.mech > 0 || hexEnem.people.character > 0) {
								var dist = getDistance(hexEnem.num, el.num);
								// is closer
								if (dist <= el.distanceToEnemie) {
									if (dist === el.distanceToEnemie && hexEnem.type !== 'head') {
										el.toBase = false;
									} else {
										el.toBase = hexEnem.type === 'head';
									}
									el.distanceToEnemie = dist;
								}
							}
						});
						if (el.toBase) {
							yesToBaseHex.push(el);
						} else {
							notToBaseHex.push(el);
						}
					}
				}
			});
			vecHexagonFiltered = notToBaseHex.length > 0 ? notToBaseHex : yesToBaseHex;

			// Ordenated to enemie distance (the closer)
			vecHexagonFiltered.sort(function (a, b) {
				var wA = a.distanceToEnemie,
					wB = b.distanceToEnemie;
				if (wA < wB) {
					return -1;
				} else if (wA > wB) {
					return 1;
				} else {
					if (a.distance < b.distance) {
						return -1;
					} else if (a.distance > b.distance) {
						return 1;
					} else {
						return a.num < b.num ? -1 : 1;
					}
				}
			});
			if (vecHexagonFiltered.length > 0) {
				hexDestiny = G.MAP[vecHexagonFiltered[0].num];
			}
		};

		switch (filter) {
			case 'worker':
				vecHexagons.forEach(function (vecHex) {
					var el = cloneObject(vecHex);

					if (el.num === hexUnit.num) {
						el.people.worker--;
					}

					// if not enemies:
					if (el.faction === null || el.faction === player.factionName) {

						el.nearEnemyAttack = 0;

						el.weight = el.people.worker + el.people.mech + el.people.character;

						var elVecs = getVecListForHex(el.num);
						elVecs.forEach(function (h) {
							if (G.MAP[h].faction !== null) {
								if (G.MAP[h].faction === player.factionName) {
									// Add friends to the weight
									el.weight += (G.MAP[h].people.worker + G.MAP[h].people.mech + G.MAP[h].people.character);
									if (h === hexUnit.num) {
										el.weight--;
									}
								} else {
									// Add near Enemies								
									el.nearEnemyAttack += G.MAP[h].people.mech + G.MAP[h].people.character;
								}
							}
						});
						// If not near Enemies						
						if (el.nearEnemyAttack === 0) {
							delete el.nearEnemyAttack;
							// If not workers
							if (el.people.worker === 0) {
								vecHexagonFiltered.push(el);
							}
						}
					}
				});

				// Ordenated to weight
				vecHexagonFiltered.sort(function (a, b) {
					var wA = a.weight || 0,
						wB = b.weight || 0;
					if (wA > wB) {
						return -1;
					} else if (wA < wB) {
						return 1;
					} else {
						if (a.distance < b.distance) {
							return -1;
						} else if (a.distance > b.distance) {
							return 1;
						} else {
							return a.num < b.num ? -1 : 1;
						}
					}
				});
				if (vecHexagonFiltered.length > 0) {
					hexDestiny = G.MAP[vecHexagonFiltered[0].num];
				}
				break;
			case 'mech':
				mechOrCharacter_No_attack();
				break;
			case 'character':
				mechOrCharacter_No_attack();
				break;
			case 'encounter_or_factory':
				var factoryHex = false;
				vecHexagons.forEach(function (vecHex) {
					var el = cloneObject(vecHex);

					// if not enemies:
					if (el.faction === null || el.faction === player.factionName) {
						if (el.people.mech === 0 && el.people.character === 0) {
							// If factory and player hasn't factory card
							if (el.type === 'factory' && !player.board.factoryCard) {
								factoryHex = G.MAP[el.num];
							} else {
								// if encounter
								if (el.encounter) {
									vecHexagonFiltered.push(el);
								}
							}
						}
					}
				});
				if (factoryHex) {
					hexDestiny = factoryHex;
				} else {
					// Ordenated to factory distance (the closer)
					vecHexagonFiltered.sort(function (a, b) {
						if (a.distance < b.distance) {
							return -1;
						} else if (a.distance > b.distance) {
							return 1;
						} else {
							return a.num < b.num ? -1 : 1;
						}
					});
					if (vecHexagonFiltered.length > 0) {
						hexDestiny = G.MAP[vecHexagonFiltered[0].num];
					}
				}
				break;
			case 'character_or_mech_attack':
				vecHexagons.forEach(function (vecHex) {
					var el = cloneObject(vecHex);

					// if yes enemies:
					if (el.faction !== null && el.faction !== player.factionName) {
						el.enemies = el.people.mech + el.people.character;
						if (el.enemies > 0) {
							vecHexagonFiltered.push(el);
						}
					}
				});

				// Ordenated by enemies
				vecHexagonFiltered.sort(function (a, b) {
					var wA = a.enemies || 0,
						wB = b.enemies || 0;
					if (wA < wB) {
						return -1;
					} else if (wA > wB) {
						return 1;
					} else {
						if (a.distance < b.distance) {
							return -1;
						} else if (a.distance > b.distance) {
							return 1;
						} else {
							return a.num < b.num ? -1 : 1;
						}
					}
				});
				if (vecHexagonFiltered.length > 0) {
					hexDestiny = G.MAP[vecHexagonFiltered[0].num];
				}
				break;
			case 'worker_attack_attack':
			
				vecHexagons.forEach(function (vecHex) {
					var el = cloneObject(vecHex);

					// if yes enemies:
					if (el.faction !== null && el.faction !== player.factionName) {
						// if not enemies forces:
						if (el.people.mech === 0 && el.people.character === 0 && el.type !== 'head') {
							vecHexagonFiltered.push(el);

						}
					}
				});
				// Ordenated by most workers
				vecHexagonFiltered.sort(function (a, b) {
					var wA = a.people.worker,
						wB = b.people.worker;
					if (wA > wB) {
						return -1;
					} else if (wA < wB) {
						return 1;
					} else {
						if (a.distance < b.distance) {
							return -1;
						} else if (a.distance > b.distance) {
							return 1;
						} else {
							return a.num < b.num ? -1 : 1;
						}
					}
				});
				if (vecHexagonFiltered.length > 0) {
					hexDestiny = G.MAP[vecHexagonFiltered[0].num];
				}
				break;
			default:
				//
		}
	};
	var setTypeToMove = function () {
		var unitToMove = null;
		unitTypes[moveAction.type].forEach(function (unit) {
			if (!unitToMove) {
				if (hexUnit.people[unit] > 0) {
					unitToMove = unit;
				}
			}
		});
		return unitToMove;
	};

	var AI = {
		move: function (ma, pl) {
			moveChoice = null;
			hexUnit = null;
			hexDestiny = null;

			moveAction = ma;
			player = pl;
			numBase = G.getBaseMapIndex(pl.factionName);

			selectHexagons();
			selectHexUnit();
			if (hexUnit) {
				selectVecHexagons();
				filterVecHexagonsByMoveType();
			}
			if (hexUnit && hexDestiny) {
				if (hexUnit.num !== hexDestiny.num) {
					moveChoice = {
						origin: hexUnit,
						destiny: hexDestiny,
						type: setTypeToMove()
					}
				}
			}
			return moveChoice;
		},
		gain: function (gains, pl) {
			var o = {
				'worker': 0,
				'mech': 0,
				'power': 0,
				'money': 0,
				'card': 0,
			};

			gains.forEach(function(ga){
				var enabledByFaction = (ga.faction && ga.faction === pl.factionName) || !ga.faction;
				if(enabledByFaction){
					var num = ga.count ? ga.count : 1;
					switch(ga.type){
						case 'worker':
							num = pl.board.worker >= num ? num : pl.board.worker;
							o.worker += num;
							break;
						case 'mech':
							num = pl.board.mech >= num ? num : pl.board.mech;
							o.mech += num;
							break;
						case 'power':
							num = (pl.power + num) > 16 ? (16 - pl.power) : num;
							o.power += num;
							break;
						default:
							o[ga.type] += num;
					}
					
				}
			});

			return o;
		}
	};
	return AI;
})();
G.evaluateAI = function (player) {
	var card = getCard();

	// Set resources to gain from AI
	G.aiResources = card.resources;

	var aiActions = null;

	// if is Autometta and skip card
	if (card.notAutometta && player.name === 'Autometta') {
		// SKIP TURN (Autometta)
	} else {
		// 1- MOVEMENT
		var moveChoice = null,
			moves = card['e' + player.strategy].move;
		moves.forEach(function (m) {
			if (!moveChoice) {
				var validFaction = m.faction ? m.faction === player.factionName : true,
					canAttack = true;
				if (m.attack && m.attack !== 'worker') {
					if (m.attack > player.power) {
						canAttack = false;
					}
				}
				if (validFaction && canAttack) {
					moveChoice = AUTOMA.move(m, player);
				}
			}
		});
		aiActions = {move: moveChoice};

		// 2- RESOURCES
		var gains = card['e' + player.strategy].gain;
		aiActions.gain = AUTOMA.gain(gains, player);
	
		// 3- RECRUIT
		aiActions.recruit = card['e' + player.strategy].recruit;
	}

	return aiActions;
};

G.evaluateFinishTurnAI = function (player) {
	return false;
};
	return G;
};
/* END CREATE GAME **************************************/
//@prepros-prepend _init.js
//@prepros-prepend create.js
//@prepros-prepend map.js
//@prepros-prepend deck.js
//@prepros-prepend automa.js
//@prepros-prepend evaluate.js

//@prepros-prepend _end.js
//@prepros-append _init.js

//@prepros-append svg.js
//@prepros-append presentation.js
//@prepros-append alert.js
//@prepros-append view_new.js
//@prepros-append view_start_turn.js
//@prepros-append view_not_autometta.js
//@prepros-append view_not_move.js
//@prepros-append view_human_start.js
//@prepros-append view_map.js
//@prepros-append view_attack_worker.js
//@prepros-append view_attack_worker_resources.js
//@prepros-append view_attack_war_resources.js
//@prepros-append view_encounter.js
//@prepros-append view_war.js
//@prepros-append view_war_bet_humans.js
//@prepros-append view_war_bet_ai.js
//@prepros-append view_war_results.js
//@prepros-append view_ai_resources.js
//@prepros-append view_ai_recruit.js

//

//@prepros-append _end.js
 /* UI *******************************************/
 (function() {

	/* SET UI SIZE SCALE *****************************/
	(function(){
		var container = document.getElementById('scythe-container'),
			width = 420,
			height = 560,
			mod = width/height,
			resizeContainer = function(){
				var w_width = window.innerWidth,
					w_height = window.innerHeight;
				if(w_width < width || w_height < height){
					var modWin = w_width/w_height;
					var scal = 1;
					if(modWin < mod){
						scal = w_width / width;
						container.style.transformOrigin = '0 0';						
					}else{
						scal = w_height / height;
						container.style.transformOrigin = '50% 0';	
					}
					container.style.transform = 'scale(' + scal + ',' + scal + ')';
				}
			};
		resizeContainer();
		window.addEventListener('resize',resizeContainer);
	})();
	/* end SET UI SIZE SCALE *****************************/

	/* LANGUAGE *****************************/
	var language = {
			'name': 'English',
			'texts': {}
		},
		setLanguage = function(langName) {
			if (window.scytheLanguages) {
				var foundLang = false;
				window.scytheLanguages.forEach(function(lang) {
					if (lang.name === langName) {
						language = cloneObject(lang);
						foundLang = true;
					}
				});
				if(!foundLang){
					language = {
						'name': 'English',
						'texts': {}
					}
				}
			};
		},
		_i = function(str) {
			return language.texts[str] || str;
		};
	/* end LANGUAGE *****************************/

	/* CURRENT VIEW *****************************/
	var currentView = ko.observable();
	currentView.extend({ notify: 'always' });
	var goToView = function(viewName,parameters){
		currentView(viewName);
	};
	/* end CURRENT VIEW *****************************/

	/* SHOW ALERT *****************************/
	var alertViewText = ko.observable('');
	alertViewText.extend({ notify: 'always' });
	var showAlert = function(text){
		alertViewText(text);
	};
	/* end SHOW ALERT *****************************/

	/* VIEW MODELS *****************************/
	var viewModelList = [],
		viewModel = {},
		bindAllModels = function(){
		viewModelList.forEach(function(vm){
				var newVM = vm();
				viewModel[newVM.viewName] = newVM;
			});
		};
	/* end VIEW MODELS *****************************/

	/* CURRENT PLAYER *****************************/
	var currentPlayer = null;
	/* end CURRENT PLAYER *****************************/

	/* AI ACTIONS *****************************/
	var AI_actions = null;
	/* end AI ACTIONS *****************************/
/* SVG POINTS DRAWING *****************************/
var SVG = {
  hexagon: {
    points: '60,0 120,33 120,99 60,132 0,99 0,33'
  },
  factory:{
    points:'M70.075,53.18l0,12.082l3.362,0l0.162,-35.238l3.523,0l0.219,23.787l6.829,-3.903l0,21.852l2.265,0.309l0,-11.317l9.565,0l0,26.911l-31.337,0l-6.041,-8.054l-6.04,8.054l-30.582,0l0,-10.309l5.537,-4.027l0,8.295l5.286,0l0,-16.863l3.524,0l0,-11.579l5.286,-3.272l5.285,3.272l0,7.551l5.286,0l0,-18.877l13.089,0l0,11.326l4.782,0Zm14.095,29.953l2.265,0l0,-7.288l-2.265,-0.309l0,7.597Z'
  },
  attack:{
    points1:'M60,37.032l19.965,11.527l0,23.053l-19.965,11.527l-19.965,-11.527l0,-23.053l19.965,-11.527Z',
    points2:'M60,18c23.18,0 42,18.82 42,42c0,23.18 -18.82,42 -42,42c-23.18,0 -42,-18.82 -42,-42c0,-23.18 18.82,-42 42,-42Zm0,2.191c21.971,0 39.809,17.838 39.809,39.809c0,21.971 -17.838,39.809 -39.809,39.809c-21.971,0 -39.809,-17.838 -39.809,-39.809c0,-21.971 17.838,-39.809 39.809,-39.809Zm0,39.021l28.635,-21.77l0.884,1.163l-3.797,2.91l0.145,1.153l-23.266,18.521l2.839,2.158l4.691,6.931l1.724,0.883l8.656,9.455c-0.907,2.601 -2.449,4.424 -4.626,5.47c-0.368,0.175 -0.808,0.031 -1.002,-0.328c-1.707,-3.158 -9.385,-17.381 -9.385,-17.381c-2.846,0.691 -3.587,-0.823 -3.325,-3.388l-2.173,-1.73l-2.173,1.73c0.262,2.565 -0.479,4.079 -3.325,3.388c0,0 -7.678,14.223 -9.385,17.381c-0.194,0.359 -0.634,0.503 -1.002,0.328c-2.177,-1.046 -3.719,-2.869 -4.626,-5.47l8.656,-9.455l1.724,-0.883l4.691,-6.931l2.839,-2.158l-23.266,-18.521l0.145,-1.153l-3.797,-2.91l0.884,-1.163l28.635,21.77Zm-2.996,6.266l-0.557,0.9c-0.124,0.547 -0.158,0.755 0.181,0.832c-0.429,0.154 -0.752,0.075 -0.985,-0.201l-0.587,0.661c0,0 1.339,0.339 1.704,-0.244c0.365,-0.582 0.244,-1.948 0.244,-1.948Zm5.992,0l0.557,0.9c0.124,0.547 0.158,0.755 -0.181,0.832c0.429,0.154 0.752,0.075 0.985,-0.201l0.587,0.661c0,0 -1.339,0.339 -1.704,-0.244c-0.365,-0.582 -0.244,-1.948 -0.244,-1.948Zm-0.498,-13.391l-4.996,0c-0.285,-0.066 -0.653,-0.387 0,-0.645c0.047,-0.019 0,-0.199 0,-0.311l0,-0.018l4.996,0l0,0.018c0,0.112 -0.047,0.292 0,0.311c0.652,0.258 0.285,0.579 0,0.645Zm0,-1.704l-4.996,0l0,-10.713l4.996,0l0,10.713Zm-6.817,-2.679l-4.997,0c-0.284,-0.066 -0.652,-0.387 0,-0.645c0.047,-0.018 0,-0.198 0,-0.311l0,-0.018l4.997,0l0,0.018c0,0.113 -0.047,0.293 0,0.311c0.652,0.258 0.285,0.579 0,0.645Zm13.635,0l-4.997,0c-0.285,-0.066 -0.652,-0.387 0,-0.645c0.047,-0.018 0,-0.198 0,-0.311l0,-0.018l4.997,0l0,0.018c0,0.113 -0.047,0.293 0,0.311c0.652,0.258 0.285,0.579 0,0.645Zm-13.635,-1.704l-4.997,0l0,-10.713l4.997,0l0,10.713Zm13.635,0l-4.997,0l0,-10.713l4.997,0l0,10.713Zm-6.818,-7.061l-4.996,0l0,-0.04c0,-0.242 0.109,-0.47 0.298,-0.621c0.286,-0.229 0.676,-0.54 0.676,-0.54l0,-3.425l3.048,0l0,3.425c0,0 0.39,0.311 0.676,0.54c0.189,0.151 0.298,0.379 0.298,0.621l0,0.04Zm-6.817,-4.382l-4.997,0l0,-0.041c0,-0.241 0.11,-0.469 0.298,-0.62c0.287,-0.229 0.676,-0.541 0.676,-0.541l0,-3.425l3.049,0l0,3.425c0,0 0.389,0.312 0.676,0.541c0.188,0.151 0.298,0.379 0.298,0.62l0,0.041Zm13.635,0l-4.997,0l0,-0.041c0,-0.241 0.11,-0.469 0.298,-0.62c0.287,-0.229 0.676,-0.541 0.676,-0.541l0,-3.425l3.049,0l0,3.425c0,0 0.389,0.312 0.676,0.541c0.188,0.151 0.298,0.379 0.298,0.62l0,0.041Zm-7.792,-0.974l-3.048,0l0,-3.166c0.079,-1.267 0.599,-2.316 1.524,-3.165l0.022,0.02c0.911,0.845 1.423,1.888 1.502,3.145l0,3.166Zm-6.817,-4.383l-3.049,0l0,-3.165c0.08,-1.267 0.6,-2.317 1.525,-3.165l0.021,0.019c0.912,0.846 1.424,1.888 1.503,3.146l0,3.165Zm13.635,0l-3.049,0l0,-3.165c0.08,-1.267 0.599,-2.317 1.524,-3.165l0.022,0.019c0.911,0.846 1.424,1.888 1.503,3.146l0,3.165Z'
  },
  worker:{
    points:'M18.258,0c3.152,0.006 5.71,2.567 5.71,5.72c0,0.91 -0.213,1.77 -0.591,2.533l0.156,0.002c4.6,0.043 8.876,2.345 10.065,3.331c1.189,0.986 2.986,3.276 2.896,4.923c-0.064,1.184 -0.858,2.124 -1.3,2.561c-0.173,0.169 -0.405,0.263 -0.647,0.263c-1.237,-0.001 -5.319,-0.004 -5.8,0c-0.569,0.005 -0.797,1.459 -0.725,2.462c0.073,1.004 4.206,7.265 5.286,9.486c0.674,1.384 1.408,3.575 1.867,5.029c0.112,0.348 0.053,0.729 -0.161,1.026c-0.214,0.298 -0.556,0.476 -0.922,0.48c-2.827,0.034 -8.703,0.105 -10.156,0.122c-0.212,0.003 -0.414,-0.088 -0.552,-0.248c-0.426,-0.492 -1.358,-1.598 -1.806,-2.354c-0.44,-0.744 -2.071,-3.19 -2.876,-4.391c-0.101,-0.152 -0.271,-0.243 -0.453,-0.243c-0.182,0 -0.352,0.091 -0.453,0.243c-0.805,1.201 -2.436,3.647 -2.876,4.391c-0.448,0.756 -1.38,1.862 -1.807,2.354c-0.138,0.16 -0.34,0.251 -0.551,0.248c-1.453,-0.017 -7.33,-0.088 -10.156,-0.122c-0.367,-0.004 -0.709,-0.182 -0.922,-0.48c-0.214,-0.297 -0.274,-0.678 -0.161,-1.026c0.459,-1.454 1.193,-3.645 1.866,-5.029c1.08,-2.221 5.214,-8.482 5.286,-9.486c0.073,-1.003 -0.156,-2.457 -0.724,-2.462c-0.481,-0.004 -4.563,-0.001 -5.801,0c-0.241,0 -0.474,-0.094 -0.647,-0.263c-0.441,-0.437 -1.235,-1.377 -1.3,-2.561c-0.09,-1.647 1.708,-3.937 2.897,-4.923c1.189,-0.986 5.465,-3.288 10.065,-3.331l0.156,-0.002c-0.378,-0.763 -0.591,-1.623 -0.591,-2.533c0,-3.153 2.558,-5.714 5.71,-5.72l0.007,0l0.002,0l0.001,0l0.008,0Z'
  },
  mech: {
    points: 'M28.925,37.459l-0.222,-11.334c-0.006,-0.282 0.103,-0.555 0.3,-0.756c0.197,-0.201 0.468,-0.315 0.75,-0.315c1.57,0 4.548,0 6.731,0c0.632,0 1.228,0.295 1.611,0.798c0.383,0.503 0.51,1.155 0.343,1.765l-2.702,9.842l-1.41,0l0,2.798l0.724,0c0.299,0 0.582,0.134 0.77,0.366c0.188,0.232 0.262,0.537 0.2,0.829l-1.694,8.048l-2.482,0l0,-5.108l-1.216,0l0,-6.933l-1.703,0Zm-22.259,12.041l-2.482,0c0,0 -1.168,-5.549 -1.694,-8.048c-0.061,-0.292 0.012,-0.597 0.2,-0.829c0.188,-0.232 0.471,-0.366 0.77,-0.366l0.724,0l0,-2.798l-1.41,0c0,0 -1.705,-6.209 -2.702,-9.842c-0.167,-0.61 -0.04,-1.262 0.343,-1.765c0.383,-0.503 0.979,-0.798 1.612,-0.798c2.182,0 5.16,0 6.73,0c0.283,0 0.553,0.114 0.75,0.315c0.198,0.201 0.306,0.474 0.3,0.756c-0.059,3.01 -0.222,11.334 -0.222,11.334l-1.703,0l0,6.933l-1.216,0l0,5.108Zm22.865,-46.824l6.567,0l0,13.135l-6.567,0l0,8.27l-2.189,0l0,8.027l-2.433,0l0,1.703l-11.189,0l0,-1.703l-2.432,0l0,-8.027l-2.19,0l0,-24.081l20.433,0l0,2.676Zm7.784,2.797l6.811,0l-0.73,12.649l-6.081,0l0,-12.649Zm-35.514,-2.797l6.325,0l0,13.865l-6.325,0l0,-13.865Zm21.162,2.675l-8.513,0l0,1.703l8.513,0l0,-1.703Z'
  },
  character: {
    points: 'M30.102,23.202l-2.254,-22.131l0.215,-0.428l0.428,-0.643l0.428,0.214l2.506,23.173c0.511,0.177 1.194,0.493 2.207,1.034c3.304,1.763 6.285,11.349 6.212,14.138c-0.072,2.79 -1.65,-1.615 -2.57,-2.785c-0.921,-1.17 -1.928,-3.213 -1.928,-3.213c0,0 -0.004,0.99 0,1.285c0.004,0.295 3.711,5.864 3.856,6.213c0.145,0.349 -0.011,1.554 -0.214,2.356c-0.204,0.802 -0.334,2.14 -0.643,2.571c-0.309,0.431 -2.356,0.214 -2.356,0.214c0,0 0.709,-0.868 1.071,-1.5c0.361,-0.632 -0.062,-2.986 -0.429,-3.427c-0.367,-0.441 -2.785,-2.999 -2.785,-2.999c0,0 1.455,2.42 1.5,2.785c0.044,0.364 -1.714,4.927 -1.714,4.927l-2.356,0.214c0,0 -0.969,-0.039 -1.071,-0.429c-0.102,-0.389 1.213,-0.686 1.713,-1.285c0.5,-0.598 0.76,-2.868 0.643,-3.642c-0.117,-0.773 -2.671,-2.77 -3.427,-3.427c-0.756,-0.657 -1.612,-2.383 -2.143,-2.571c-0.53,-0.187 -3.203,-0.441 -4.07,-0.214c-0.867,0.227 -2.842,1.657 -3.213,2.357c-0.371,0.699 -0.844,4.002 -1.071,5.355c-0.227,1.353 -1.714,3.642 -1.714,3.642l-5.355,0.214c0,0 -0.582,-0.664 -0.643,-0.643c-0.061,0.022 1.585,-0.553 2.142,-2.142c0.557,-1.588 0.628,-7.678 0.214,-8.569c-0.413,-0.89 -4.469,-4.671 -5.569,-5.783c-1.1,-1.113 -2.142,-3.428 -2.142,-3.428c0,0 -1.079,0.437 -1.928,0.643c-0.85,0.205 -1.928,0.214 -1.928,0.214l-1.714,-1.714c0,0 2.398,-1.757 2.999,-2.57c0.601,-0.814 0.629,-0.819 1.071,-2.357c0.442,-1.538 -0.428,-2.57 -0.428,-2.57l1.499,0.214l0.429,-0.857c0,0 9.394,5.182 11.139,5.998c1.745,0.816 10.156,1.782 11.996,1.714c0.634,-0.024 1.024,-0.113 1.397,-0.148Zm-10.428,14.246c0.115,-0.532 0.23,-0.954 0.337,-1.16c0.376,-0.726 2.382,-1.994 3.262,-2.23c0.881,-0.235 2.738,0.028 3.276,0.223c0.538,0.194 2.05,2.198 2.818,2.88c0.209,0.186 0.57,0.443 0.987,0.735c-0.583,0.171 -1.226,0.353 -1.649,0.449c-0.945,0.215 -2.142,0.214 -2.142,0.214c0,0 0.104,1.854 0.214,1.928c0.111,0.074 0.127,1.187 0.429,1.928c0.301,0.741 0,1.5 0,1.5l0,1.071l-5.57,0.214c0,0 -0.046,-0.884 0.214,-1.071c0.261,-0.187 1.916,-0.98 1.928,-1.071c0.012,-0.092 -0.136,-1.426 -0.214,-2.357c-0.079,-0.93 0,-2.57 0,-2.57c0,0 -0.484,-0.044 -1.714,-0.214c-0.556,-0.078 -1.412,-0.28 -2.176,-0.469Zm-4.893,6.681c0,0 0.957,-1.272 1.5,-2.785c0.542,-1.513 0.214,-4.07 0.214,-4.07c0,0 -0.728,2.188 -1.071,3.213c-0.344,1.025 -0.643,3.642 -0.643,3.642Zm4.713,-37.488l0,-1.071l0.428,-0.429l0,-0.857l-1.071,-0.428l0.643,-0.429l0,-0.642l-0.643,-0.643c0,0 3.454,0.053 4.284,0.214c0.831,0.162 3.214,1.071 3.214,1.071l0,0.429l-0.429,0.214l-0.214,0.857l-0.214,0.214l-0.214,1.286l0.428,0.214l-0.428,0.428l0,1.285l1.285,-0.428l0.214,1.071l-0.642,0.857c0,0 1.494,2.004 1.928,2.785c0.277,0.5 0.902,6.249 1.316,10.316c-0.074,0.005 -0.152,0.008 -0.233,0.012c-1.554,0.059 -7.722,-0.625 -10.774,-1.343c0.505,-2.228 1.336,-5.129 1.336,-5.129c0,0 -0.049,-0.641 -0.214,-1.286c-0.165,-0.644 -0.508,-1.74 -0.643,-2.356c-0.134,-0.615 0,-1.285 0,-1.285l-0.214,-0.857c0,0 0.424,-0.469 0.857,-0.643c0.433,-0.174 0.601,0.425 1.071,0c0.47,-0.424 0,-0.642 0,-0.642l-0.429,-0.643l0.215,-0.429l0.214,-0.856l-0.429,-0.857l-0.642,0Zm9.854,-6.213c0,0 1.743,-0.003 2.57,0.215c0.828,0.218 2.075,1.082 2.143,1.928c0.067,0.845 0,1.071 0,1.071c0,0 1.002,-0.327 1.499,-0.215c0.498,0.113 0.716,0.22 1.285,0.429c0.57,0.209 1.172,0.681 1.5,1.071c0.328,0.39 0.853,0.221 1.285,0.214c0.432,-0.006 1.379,-0.273 1.714,0c0.335,0.273 1.285,0.643 1.285,0.643c0,0 0.279,2.15 0.429,2.999c0.15,0.849 0.615,2.743 0.642,3.427c0.028,0.684 0.048,2.267 0.215,2.999c0.166,0.733 0.722,2.718 0.856,3.428c0.135,0.71 0.001,2.133 -0.214,2.356c-0.215,0.224 -0.507,-0.494 -1.285,-0.857c-0.779,-0.362 -2.135,-1.002 -2.571,-1.071c-0.435,-0.068 -2.009,-0.261 -2.356,-0.428c-0.347,-0.167 -1.769,-0.854 -2.142,-1.071c-0.374,-0.217 -1.451,-1.232 -1.5,-1.5c-0.049,-0.267 -0.359,-1.005 -1.071,-1.285c-0.712,-0.28 -1.304,-0.885 -1.928,-1.071c-0.623,-0.186 -0.857,-0.429 -0.857,-0.429l-1.713,-11.781l0.214,-1.072Z'
  }
};
/* end SVG POINTS DRAWING *****************************/
/* VIEW: PRESENTATION *****************************/
var presentationVM = (function() {
	var vm = {
		current: ko.observable(true),
		lan: ko.observable('English'),
		languages: [],
		txt_continue: ko.observable(_i('Continue'))
	};

	if (window.scytheLanguages) {
		vm.isLang = true;
		vm.languages.push('English');
		window.scytheLanguages.forEach(function(lang) {
			vm.languages.push(lang.name);
		})
	} else {
		vm.isLang = false;
	}
	
	vm.lan.subscribe(function(v){		
		setLanguage(v);
		// texts
		vm.txt_continue(_i('Continue'));
	});

	vm.continueAction = function(){
		bindAllModels();
		vm.current(false);
		goToView('view_new');
	};

	ko.applyBindings(vm, document.getElementById('presentation'));
	return vm;
})();
/* end VIEW: PRESENTATION *****************************/
/* VIEW: ALERT *****************************/
viewModelList.push(function() {
	var vm = {
		/*-----------------------*/
		viewName: 'view_alert',
		/*-----------------------*/
		current: ko.observable(false),
		// texts
		txt_ok: _i('Ok'),
		text:  ko.observable('')
	};

	vm.closeAlert = function(){
		alertViewText('');
	};

	alertViewText.subscribe(function(newValue) {
		vm.current(newValue !== '');
		vm.text(newValue);
	});
	
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: ALERT *****************************/
/* VIEW: NEW *****************************/
/* Faction Button */
var factionBtnVM = function(factionIndex, playerTypeIndex) {

	// Initial Player
	var faction = GAMECONFIG.factions[factionIndex],	
		player = GAMECONFIG.playerTypes[playerTypeIndex],
		playerTypesLength = GAMECONFIG.playerTypes.length,
		className = player.name === 'None' ? 'disabled' : faction.name;

	var vm = {
		title: _i(capitalize(faction.name)),
		playerTypeIndex: playerTypeIndex,
		icon: 'images/factions/' + faction.name + '.png',
		power: faction.power,
		cards: faction.cards,
		className: ko.observable('faction-item ' + className),
		playerName: ko.observable(_i(player.name)),
		playerIcon: ko.observable(player.icon)		
	};

	vm.changePlayer = function(){
		vm.playerTypeIndex++;
		vm.playerTypeIndex = vm.playerTypeIndex >= playerTypesLength ? 0 : vm.playerTypeIndex;

		var player = GAMECONFIG.playerTypes[vm.playerTypeIndex],
			className = player.name === 'None' ? 'disabled' : faction.name;

		vm.className('faction-item ' + className);
		vm.playerName(_i(player.name));
		vm.playerIcon(player.icon);
	};

	return vm;
};

/* View New VM */
viewModelList.push(function() {

	var vm = {
		/*-----------------------*/
		viewName: 'view_new',
		/*-----------------------*/
		current: ko.observable(false),
		// texts
		txt_title: _i('New game'),
		txt_present: _i('Choose factions and players:'),
		txt_continue:  _i('Continue')
	};

	// Create Faction Buttons
	var facts = [];
	for (var i = 0; i < GAMECONFIG.factions.length; i++) {
		var playerTypeIndex = 0;
		playerTypeIndex = i === 0 ? 1 : playerTypeIndex; // human
		playerTypeIndex = i === 2 ? 2 : playerTypeIndex; // ai - autometta

		var newFact = factionBtnVM(i, playerTypeIndex);
		facts.push(newFact);
	};
	vm.factions = ko.observableArray(facts);

	vm.continueAction = function(){
		var factions = vm.factions(),
			areHumans = false,
			areAI = false,
			factionsToStart = [];

		factions.forEach(function(fact){
			if(fact.playerTypeIndex === 1){
				areHumans = true; // There is Human player
			}
			if(fact.playerTypeIndex > 1){
				areAI = true; // There is AI player
			}
			factionsToStart.push(fact.playerTypeIndex);
		});		
		
		//if(areHumans && areAI){
			GAME = createGame(factionsToStart);
			goToView('view_start_turn');			
		//}else{
		// 	showAlert(_i('Please, select almost 1 Human player and 1 Automa player.'));
		//}
	};

	currentView.subscribe(function(newValue) {
		vm.current(newValue === vm.viewName);
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: NEW *****************************/
/* VIEW: START TURN *****************************/
viewModelList.push(function () {
	var vm = {
		/*-----------------------*/
		viewName: 'view_start_turn',
		/*-----------------------*/
		current: ko.observable(false),
		// texts
		txt_title: _i('Turn of'),
		txt_continue: _i('Continue'),
		title: ko.observable(''),
		icon: ko.observable(''),
		playerName: ko.observable(''),
		playerIcon: ko.observable(''),
		ai: ko.observable(false),
		timeline: ko.observableArray(),
		ai_position: ko.observable(''),
		classMarker: ko.observable('')
	};

	vm.continueAction = function () {
		if (currentPlayer.ai) {
			// if is Autometta, and not play this turn
			if(!AI_actions){
				goToView('view_not_autometta');
			}else{
				// if there are unit to move
				if(AI_actions.move){
					goToView('view_map');
				}else{
					//goToView('view_not_move');
					goToView('view_ai_resources');
				}
			}
		} else {
			goToView('view_human_start');
		}
	};

	currentView.subscribe(function (newValue) {
		vm.current(newValue === vm.viewName);
		if (GAME && newValue === vm.viewName) {
			currentPlayer = GAME.getCurrentPlayer();

			vm.title(_i(capitalize(currentPlayer.factionName)));
			vm.icon('images/factions/' + currentPlayer.factionName + '.png');
			vm.classMarker(currentPlayer.factionName);
			vm.playerName(_i(currentPlayer.name));
			vm.playerIcon(currentPlayer.icon);
			vm.ai(currentPlayer.ai);

			if (currentPlayer.ai) {
				// FOR AI player

				// timeline
				var timeline = [];

				var notRiver = true,
					x = 0,
					y = 0,
					step_x = 0,
					step_y = 0;

				currentPlayer.timeline.forEach(function (t, i) {
					if (t.crossRiver && notRiver) {
						notRiver = false;
					}
					var o = {
						notRiver: notRiver
					};
					o.star = t.star ? true : false;
					o.one = i === 0 ? true : false;
					o.two = t.changeEstrategy ? true : false;

					timeline.push(o);

					if (currentPlayer.step === i) {
						step_x = x;
						step_y = y;
					}
					x++;
					if (x >= 4) {
						x = 0;
						y++;
					}
				});

				vm.timeline(timeline);
				var w = 176 / 4,
					sty = 'top:' + ((w + 1) * step_y) + 'px;';
				sty += 'left:' + (w * step_x) + 'px';
				vm.ai_position(sty);

				// SET AI Actions
				AI_actions = GAME.evaluateAI(currentPlayer);
			//	log('AI_actions',AI_actions);
			}
		}
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: START TURN *****************************/
/* VIEW: NOT AUTOMETTA *****************************/
viewModelList.push(function () {
	var vm = {
		/*-----------------------*/
		viewName: 'view_not_autometta',
		/*-----------------------*/
		current: ko.observable(false),
		// texts
		txt_title: ko.observable(''),
		txt_continue: _i('Continue'),
		title: ko.observable(''),
		icon: ko.observable(''),
		playerName: ko.observable(''),
		playerIcon: ko.observable(''),
	};

	vm.continueAction = function () {
		GAME.advancePlayer();
		goToView('view_start_turn');
	};

	currentView.subscribe(function (newValue) {
		vm.current(newValue === vm.viewName);
		if (GAME && newValue === vm.viewName) {
			currentPlayer = GAME.getCurrentPlayer();

			vm.title(_i(capitalize(currentPlayer.factionName)));
			vm.icon('images/factions/' + currentPlayer.factionName + '.png');
			
			vm.playerName(_i(currentPlayer.name));
			vm.playerIcon(currentPlayer.icon);

			var txt = _i('%faction skip this turn (because is in "Autometta" mode).');

			txt = txt.replace('%faction',capitalize(_i(currentPlayer.factionName)));

			vm.txt_title(txt);
		}
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: NOT AUTOMETTA *****************************/
/* VIEW: NOT MOVE *****************************/
viewModelList.push(function () {
	var vm = {
		/*-----------------------*/
		viewName: 'view_not_move',
		/*-----------------------*/
		current: ko.observable(false),
		// texts
		txt_title: ko.observable(''),
		txt_continue: _i('Continue'),
		title: ko.observable(''),
		icon: ko.observable(''),
		playerName: ko.observable(''),
		playerIcon: ko.observable(''),
	};

	vm.continueAction = function () {		
		// continue to evaluate AI resources
		log('continue to evaluate AI resources');
		goToView('view_ai_resources');
	};

	currentView.subscribe(function (newValue) {
		vm.current(newValue === vm.viewName);
		if (GAME && newValue === vm.viewName) {
			currentPlayer = GAME.getCurrentPlayer();

			vm.title(_i(capitalize(currentPlayer.factionName)));
			vm.icon('images/factions/' + currentPlayer.factionName + '.png');
			
			vm.playerName(_i(currentPlayer.name));
			vm.playerIcon(currentPlayer.icon);

			var txt = _i('%faction does not move any unit this turn.');

			txt = txt.replace('%faction',capitalize(_i(currentPlayer.factionName)));

			vm.txt_title(txt);
		}
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: NOT MOVE *****************************/
/* VIEW: HUMAN START *****************************/
viewModelList.push(function() {
	var vm = {
		/*-----------------------*/
		viewName: 'view_human_start',
		/*-----------------------*/
		current: ko.observable(false),
		// texts
		title: ko.observable(''),
		icon: ko.observable(''),
		playerName: ko.observable(''),
		playerIcon: ko.observable(''),
		txt_choose:  _i('Please, choose one action to do:'),
		txt_move_add:  _i('MOVE or ADD units'),
		txt_continue:  _i('End your turn')		
	};

	vm.moveOrAddAction = function(){
		goToView('view_map');
	};

	vm.continueAction = function(){
		GAME.advancePlayer();
		goToView('view_start_turn');
	};

	currentView.subscribe(function(newValue) {
		vm.current(newValue === vm.viewName);
		if(GAME && newValue === vm.viewName){
			vm.title(_i(capitalize(currentPlayer.factionName)));
			vm.icon('images/factions/' + currentPlayer.factionName + '.png');
			vm.playerName(_i(currentPlayer.name));
			vm.playerIcon(currentPlayer.icon);
		}
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: HUMAN START *****************************/
/* VIEW: MAP *****************************/

/* Human Data for map */
var mapHumanAction = 'move',
	mapHumanElement = 'worker',
	mapHumanMoveElement = ko.observable(null),
	mapHumanRollBackElement = ko.observable(null),
	mapHumanChanges = ko.observable(null),
	arrow = {
		x1: 0,
		y1: 0,
		x2: 0,
		y2: 0,
	};
/* end Human Data for map */

/* Hexagon Map VM */
var hexagonMap = function (data, aiType) {
	var num = '' + data.num,
		row = parseInt(num.charAt(0), 10),
		col = parseInt(num.charAt(1), 10),
		dx = 65 + (isOdd(row) ? 60 : 0) + (120 * (col - 1)),
		dy = 30 + (99 * (row - 1));

	var vm = {
		num: data.num,
		distance: data.distance,
		withEnemies: ko.observable(false),
		attack: null,
		encounter: data.encounter,

		// Faction
		faction: ko.observable(data.faction),
		peopleFactionClass: ko.observable(data.faction ? 'people ' + data.faction : ''),

		// DRAW
		points: SVG.hexagon.points,
		workerPoints: SVG.worker.points,
		mechPoints: SVG.mech.points,
		characterPoints: SVG.character.points,
		factoryPoints: SVG.factory.points,
		attackPoints1: SVG.attack.points1,
		attackPoints2: SVG.attack.points2,
		origin: aiType === 'origin',
		destiny: aiType === 'destiny',

		transform: 'translate(' + dx + ',' + dy + ')',
		className: 'hex' + (data.type === 'head' ? '' : ' hexagon'),
		factionHeadImg: data.type === 'head',
		factionHeadImgWidth: 84,
		factionHeadImgX: 18,
		factionHeadImgY: 18,
		factionHeadImgHref: 'images/factions/' + (data.factionHead || '') + '.png',
		factory: data.type === 'factory',

		// PEOPLE
		worker: ko.observable(data.people.worker),
		mech: ko.observable(data.people.mech),
		character: ko.observable(data.people.character)
	};


	if (vm.destiny) {
		arrow.x1 = dx + 60;
		arrow.y1 = dy + 66;
	}
	if (vm.origin) {
		arrow.x2 = dx + 60;
		arrow.y2 = dy + 66;
	}



	/* HUMAN ACTIONS */
	var addElement = function (element) {
			var currentfaction = vm.faction();
			if (currentfaction === null) {
				vm.faction(element.faction);
				vm.peopleFactionClass('people ' + element.faction);
				var num = vm[element.type]();
				num++;
				vm[element.type](num);
			} else {
				if (currentfaction === element.faction) {
					var num = vm[element.type]();
					num++;
					vm[element.type](num);
				} else {
					if (!vm.factionHeadImg) {
						// Attack
						if (element.type !== 'worker') {
							vm.withEnemies(true);
							if (!vm.attack) {
								vm.attack = {
									faction: element.faction
								};
							}
							if (!vm.attack[element.type]) {
								vm.attack[element.type] = 1;
							} else {
								vm.attack[element.type] += 1;
							}
						} else {
							// Roll back worker
							mapHumanRollBackElement(element);
						}
					} else {
						// Roll back item
						mapHumanRollBackElement(element);
					}
				}
			}
			mapHumanMoveElement(null);
			var mhCh = mapHumanChanges();
			if (!mhCh) {
				mhCh = {};
			}
			mhCh[vm.num] = true;
			mapHumanChanges(mhCh);
		},
		quitElement = function (elementName) {
			mapHumanMoveElement({
				'type': elementName,
				'faction': vm.faction(),
				'from': data.num
			});
			var num = vm[elementName]();
			num = num < 1 ? 0 : num - 1;
			vm[elementName](num);

			// if hex is empty
			var poblation = vm.worker() + vm.mech() + vm.character();
			if (poblation === 0 && !vm.factionHeadImg) {
				vm.faction(null);
			}
			var mhCh = mapHumanChanges();
			if (!mhCh) {
				mhCh = {};
			}
			mhCh[vm.num] = true;
			mapHumanChanges(mhCh);
		};
	vm.onClickHexagon = function () {
		if (!currentPlayer.ai) {
			if (mapHumanAction === 'move') {
				// MOVE
				var element = mapHumanMoveElement();
				if (element) {
					// Add element
					addElement(element);
				} else {
					if (currentPlayer.factionName === vm.faction()) {
						var el = vm[mapHumanElement]();
						if (el > 0) {
							quitElement(mapHumanElement);
						}
					}
				}
			} else {
				// ADD
				var fact = vm.faction();
				if (currentPlayer.factionName === fact || fact === null) {
					var element = {
						type: mapHumanElement,
						faction: currentPlayer.factionName
					};
					addElement(element);
				}
			}
		}
	};
	/* end HUMAN ACTIONS */

	return vm;
};

/* View Map */
viewModelList.push(function () {
	var mapCursorMove = false;
	var vm = {
		/*-----------------------*/
		viewName: 'view_map',
		/*-----------------------*/
		current: ko.observable(false),

		// draw
		workerPoints: SVG.worker.points,
		mechPoints: SVG.mech.points,
		characterPoints: SVG.character.points,
		viewBox: '0 0 1080 990',
		arrowTransform: ko.observable(''),
		aiSelectedUnit: ko.observable(''),

		// human
		hexagons: ko.observableArray(),
		addAction: ko.observable(false),
		currentFaction: ko.observable(false),
		mapCursorVisible: ko.observable(false),
		mapCursorMech: ko.observable(false),
		mapCursorWorker: ko.observable(false),
		mapCursorCharacter: ko.observable(false),
		undoChangesEnabled: ko.observable(false),
		isAddAction: ko.observable(false),
		selectedUnit: ko.observable('worker'),
		disabledCharacter: ko.observable(false),
		viewHumanOptions: ko.observable(true),
		visibleArrow: ko.observable(false),

		// text
		txt_lead_1: ko.observable(_i('Move your pieces by selecting in map')),
		txt_lead_2: ko.observable(_i('or add new pieces')),
		txt_continue: _i('Continue'),
		txt_add: _i('Add'),
		txt_move: _i('Move'),
	};

	// AI changes
	var origin = '',
		destiny = '',
		typeAIunitMove = '';

	var resetMap = function () {
		if (GAME) {
			/* Human Data for map */
			mapHumanAction = 'move';
			mapHumanElement = 'worker';
			mapHumanChanges(null);
			mapHumanMoveElement(null);
			mapHumanRollBackElement(null);
			// human
			vm.isAddAction(false);
			vm.selectedUnit('worker');
			vm.currentFaction(currentPlayer.factionName);
			vm.viewHumanOptions(!currentPlayer.ai);
			vm.visibleArrow(currentPlayer.ai);

			if (!currentPlayer.ai) {
				//human
				vm.txt_lead_1(_i('Move your pieces by selecting in map,'));
				vm.txt_lead_2(_i('or add new pieces'));
			} else {
				//ai
				origin = AI_actions.move.origin.num;
				destiny = AI_actions.move.destiny.num;
				typeAIunitMove = AI_actions.move.type;


				var txt = _i('Move the %faction %unit from/to the selected territory.');

				txt = txt.replace('%faction',currentPlayer.factionName);
				txt = txt.replace('%unit',typeAIunitMove);

				vm.txt_lead_1(txt);
				vm.txt_lead_2('');
				vm.aiSelectedUnit(vm[typeAIunitMove + 'Points']);

			}

			// create hexagons
			var hexs = [];
			for (var a in GAME.MAP) {
				var d = GAME.MAP[a];

				var aiType = null;
				if (currentPlayer.ai) {
					// AI
					if (d.num === origin) {
						aiType = 'origin';
					}
					if (d.num === destiny) {
						aiType = 'destiny';
					}
				}

				var h = hexagonMap(d, aiType);
				hexs.push(h);
			}
			vm.hexagons(hexs);


			//ARROW
			if (currentPlayer.ai) {
				var xd = arrow.x2 - arrow.x1,
					yd = arrow.y2 - arrow.y1,
					long = Math.sqrt((xd * xd) + (yd * yd)) / 100,
					dAng = xd < 0 ? 180 : 0,
					ang = (Math.atan(yd / xd) * 180 / Math.PI) + dAng;

				vm.arrowTransform('translate(' + arrow.x1 + ',' + arrow.y1 + ') rotate(' + ang + ') scale(' + long + ',.7)');
			}

		}
	};

	// Human actions
	vm.selectWorker = function () {
		mapHumanElement = 'worker';
		vm.selectedUnit(mapHumanElement);
	};
	vm.selectMech = function () {
		mapHumanElement = 'mech';
		vm.selectedUnit(mapHumanElement);
	};
	vm.selectCharacter = function () {
		if (mapHumanAction === 'move') {
			mapHumanElement = 'character';
			vm.selectedUnit(mapHumanElement);
		}
	};
	vm.undoChanges = function () {
		if (vm.undoChangesEnabled()) {
			resetMap();
		}
	};
	vm.toggleAction = function () {
		var v = !vm.isAddAction();
		vm.isAddAction(v);
		mapHumanAction = v ? 'add' : 'move';
		if (mapHumanAction === 'add' && mapHumanElement === 'character') {
			mapHumanElement = 'worker';
			vm.selectedUnit(mapHumanElement);
		}
		vm.disabledCharacter(mapHumanAction === 'add');
	};

	// Continue
	vm.continueAction = function () {
		if (!mapHumanMoveElement()) {		

			if (!currentPlayer.ai) {
				// Save Human changes
				var hexs = vm.hexagons();

				var mhCh = mapHumanChanges();
				if (!mhCh) {
					mhCh = {};
				}
				hexs.forEach(function (hex) {
					if (mhCh[hex.num]) {
						var o = {
							'people': {
								'worker': hex.worker(),
								'mech': hex.mech(),
								'character': hex.character()
							},
							'faction': hex.faction()
						};

						if (hex.attack) {
							o.attack = cloneObject(hex.attack);
						}
						GAME.MAP[hex.num] = extendObject(GAME.MAP[hex.num], o);

					}
				});
			} else {
				// Save AI changes

				// origin = AI_actions.move.origin.num;
				// destiny = AI_actions.move.destiny.num;
				// typeAIunitMove = AI_actions.move.type;

				// 1- Quit the unit from origin
				GAME.MAP[origin].people[typeAIunitMove]--;

				// 2- Put the unit in destiny
				if(GAME.MAP[destiny].faction === null || GAME.MAP[destiny].faction === currentPlayer.factionName){
					// if is not enemies
					GAME.MAP[destiny].people[typeAIunitMove]++;
					
				}else{
					// is enemies => attack
					GAME.MAP[destiny].attack = {
						'faction': currentPlayer.factionName
					};
					GAME.MAP[destiny].attack[typeAIunitMove] = 1;
				}
			}
			// Reset status
			mapHumanChanges(null);
			mapHumanMoveElement(null);
			mapHumanRollBackElement(null);
			mapCursorMove = false;

			// CONTINUE
			GAME.hexConflict = GAME.evaluateAttack();

			if (GAME.hexConflict.workers.length > 0) {
				// Attack workers
				goToView('view_attack_worker');
			} else {
				if (GAME.hexConflict.war) {
					goToView('view_war');
				} else {
					var hexEncounter = GAME.evaluateEncounter();
					if (hexEncounter) {
						// Encounter
						goToView('view_encounter');
					} else {
						if (!currentPlayer.ai) {
							//continue to human start
							goToView('view_human_start');
						} else {
							// continue to evaluate AI resources
							log('continue to evaluate AI resources');
						}
					}
				}
			}
		};
	};

	/* SUBSCRIPTIONS */
	mapHumanMoveElement.subscribe(function (v) {
		var isMoving = v !== null;
		vm.mapCursorVisible(isMoving);
		mapCursorMove = isMoving;
		if (isMoving) {
			vm.mapCursorMech(v.type === 'mech');
			vm.mapCursorWorker(v.type === 'worker');
			vm.mapCursorCharacter(v.type === 'character');
		}
	});
	mapHumanRollBackElement.subscribe(function (v) {
		if (v !== null) {
			var hexs = vm.hexagons(),
				change = false;
			hexs.forEach(function (h) {
				if (h.num === v.from) {
					var p = h[v.type]();
					h[v.type](p + 1);
					h.faction(v.faction);
					change = true;
				}
			});
			if (change) {
				vm.hexagons(hexs);
			}
			mapHumanRollBackElement(null);
		}
	});
	mapHumanChanges.subscribe(function (v) {
		vm.undoChangesEnabled(!(v === null));
	});

	/* EVENT WINDOWS */
	var view_map = document.getElementById('view_map');
	var mapCursor = document.getElementById('map-cursor');
	window.addEventListener('mousedown', function (e) {
		var x = e.pageX - view_map.getBoundingClientRect().left - 16,
			y = e.pageY - 16;
		mapCursor.style = 'top:' + y + 'px;left:' + x + 'px';
	});
	window.addEventListener('mousemove', function (e) {
		if (mapCursorMove) {
			var x = e.pageX - view_map.getBoundingClientRect().left - 16,
				y = e.pageY - 16;
			mapCursor.style = 'top:' + y + 'px;left:' + x + 'px';
		}
	});


	/* VIEW SUBSCRIPTION */
	currentView.subscribe(function (newValue) {
		vm.current(newValue === vm.viewName);
		if (newValue === vm.viewName) {
			resetMap();
		}
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: MAP *****************************/
/* VIEW: ATTACK WORKERS *****************************/
viewModelList.push(function () {
	var vm = {
		/*-----------------------*/
		viewName: 'view_attack_worker',
		/*-----------------------*/
		current: ko.observable(false),

		// draw
		workerPoints: SVG.worker.points,
		mechPoints: SVG.mech.points,

		// texts
		title_1: ko.observable(''),
		icon_1: ko.observable('player-icon-unit'),
		playerName_1: ko.observable(''),
		playerIcon_1: ko.observable(''),
		title_2: ko.observable(''),
		icon_2: ko.observable('player-icon-unit'),
		playerName_2: ko.observable(''),
		playerIcon_2: ko.observable(''),
		txt_attack: ko.observable(''),
		txt_result: ko.observable(''),
		txt_continue: _i('Continue')
	};

	var p1, p2;

	vm.continueAction = function () {
		
		// GAME.advancePlayer();
		if (p1.ai && p2.ai) {
			GAME.hexConflict.workers.shift();
			//log(GAME.hexConflict);
			if (GAME.hexConflict.workers.length > 0) {
				// Attack workers
				goToView('view_none');
				setTimeout(function(){
					goToView('view_attack_worker');
				},200);
			} else {
				if (GAME.hexConflict.war) {
					// War
					goToView('view_war');
				} else {
					var hexEncounter = GAME.evaluateEncounter();
					if(hexEncounter){
						// Encounter
						goToView('view_encounter');
					}else{
						if (!currentPlayer.ai) {
							//continue to human start
							goToView('view_human_start');
						} else {
							// continue to evaluate AI resources
							log('Evaluate');
						}
					}
				}
			}
		} else {
			goToView('view_attack_worker_resources');
		}
	};

	currentView.subscribe(function (newValue) {
		vm.current(newValue === vm.viewName);
		if (GAME && newValue === vm.viewName) {
			var baseIndex, num_of_Worker = 0;

			if (GAME.hexConflict.workers.length > 0) {
				var hex_attack = GAME.hexConflict.workers[0];

				p1 = GAME.getPlayerByFaction(hex_attack.attack.faction);
				p2 = GAME.getPlayerByFaction(hex_attack.faction);
				baseIndex = GAME.getBaseMapIndex(hex_attack.faction);

				num_of_Worker = hex_attack.people.worker;

				// send workers to base
				GAME.MAP[baseIndex].people.worker += hex_attack.people.worker;

				// quit of hex_attack				
				GAME.MAP[hex_attack.num].people.worker = 0;

				// Renew faction, mech and/or character
				GAME.MAP[hex_attack.num].faction = hex_attack.attack.faction;
				GAME.MAP[hex_attack.num].people.mech = hex_attack.attack.mech || 0;
				GAME.MAP[hex_attack.num].people.character = hex_attack.attack.character || 0;

				// Reset attack
				GAME.MAP[hex_attack.num].attack = null;

				vm.title_1(_i(capitalize(p1.factionName)));
				vm.icon_1('player-icon-unit ' + p1.factionName);
				vm.playerName_1(_i(p1.name));
				vm.playerIcon_1(p1.icon);
				vm.title_2(_i(capitalize(p2.factionName)));
				vm.icon_2('player-icon-unit ' + p2.factionName);
				vm.playerName_2(_i(p2.name));
				vm.playerIcon_2(p2.icon);

				var textAttack = num_of_Worker === 1 ? 'attack % worker' : 'attack % workers',
					i_textAttack = _i(textAttack);
				vm.txt_attack(i_textAttack.replace('%', num_of_Worker));

				var i_textTerritories = '';

				var textResult = _i('Each of $faction-2s workers on that territory immediately retreats to their factions home base, leaving behind any resource tokens. $faction-1 loses % popularity for the workers he forced to retreat (theyre not happy with you for forcing them off their land).'),
					i_textResult = textResult.replace('$faction-1', _i(capitalize(p1.factionName))).replace('$faction-2', _i(capitalize(p2.factionName))).replace('%', num_of_Worker);
				vm.txt_result(i_textResult);

				//	GAME.hexConflict.workers = [];
			}
		}
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: ATTACK WORKERS *****************************/
/* VIEW: ATTACK WORKERS RESOURCES *****************************/
viewModelList.push(function () {
	var vm = {
		/*-----------------------*/
		viewName: 'view_attack_worker_resources',
		/*-----------------------*/
		current: ko.observable(false),

		// draw
		workerPoints: SVG.worker.points,
		mechPoints: SVG.mech.points,

		// texts
		title_1: ko.observable(''),
		icon_1: ko.observable('player-icon-unit'),
		playerName_1: ko.observable(''),
		playerIcon_1: ko.observable(''),
		title_2: ko.observable(''),
		icon_2: ko.observable('player-icon-unit'),
		playerName_2: ko.observable(''),
		playerIcon_2: ko.observable(''),
		txt_attack: ko.observable(''),
		txt_result: ko.observable(''),
		txt_continue: _i('Continue'),
		resourceList: ko.observableArray(),
		resourceListVisible: ko.observable(false),
		allResources: ko.observable(false)
	};

	vm.continueAction = function () {
		GAME.hexConflict.workers.shift();
		if (GAME.hexConflict.workers.length > 0) {
			// Attack workers
			goToView('view_attack_worker');
		} else {
			if (GAME.hexConflict.war) {
				// War
				goToView('view_war');
			} else {
				var hexEncounter = GAME.evaluateEncounter();
				if (hexEncounter) {
					// Encounter
					goToView('view_encounter');
				} else {
					if (!currentPlayer.ai) {
						//continue to human start
						goToView('view_human_start');
					} else {
						// continue to evaluate AI resources
						log('continue to evaluate AI resources');
					}
				}
			}
		}

	};

	currentView.subscribe(function (newValue) {
		vm.current(newValue === vm.viewName);
		if (GAME && newValue === vm.viewName) {
			var p1, p2, num_of_Worker = 0;

			if (GAME.hexConflict.workers.length > 0) {
				var hex_attack = GAME.hexConflict.workers[0];

				p1 = GAME.getPlayerByFaction(hex_attack.attack.faction);
				p2 = GAME.getPlayerByFaction(hex_attack.faction);
				num_of_Worker = hex_attack.people.worker;

				vm.title_1(_i(capitalize(p1.factionName)));
				vm.icon_1('player-icon-unit ' + p1.factionName);
				vm.playerName_1(_i(p1.name));
				vm.playerIcon_1(p1.icon);
				vm.title_2(_i(capitalize(p2.factionName)));
				vm.icon_2('player-icon-unit ' + p2.factionName);
				vm.playerName_2(_i(p2.name));
				vm.playerIcon_2(p2.icon);

				var textAttack = num_of_Worker === 1 ? 'attack % worker' : 'attack % workers',
					i_textAttack = _i(textAttack);
				vm.txt_attack(i_textAttack.replace('%', num_of_Worker));

				if (!currentPlayer.ai) {
					// attack human

					if (p2.ai) {
						// vs. ai
						vm.allResources(false);
						var typeRes = hex_attack.type;

						var required = typeRes === 'iron' || typeRes === 'farm' || typeRes === 'oil' || typeRes === 'wood';

						if (GAME.aiResources > 0 && required) {

							var txt_result = _i('Put %num %type in the territory.');

							txt_result = txt_result.replace('%num', GAME.aiResources);
							txt_result = txt_result.replace('%type', typeRes);

							vm.txt_result(txt_result);

							var list = [],
								counter = GAME.aiResources;

							while (counter > 0) {
								list.push({
									type: typeRes
								});
								counter--;
							}
							vm.resourceListVisible(true);
							vm.resourceList(list);

						} else {
							vm.resourceListVisible(false);
							vm.txt_result(_i('There are not resources in the territory.'));
						}

					} else {
						// vs. human
						vm.resourceListVisible(false);
						vm.allResources(true);
						var txt_result = _i('%faction obtain all resources in the territory.');
						txt_result = txt_result.replace('%faction', _i(capitalize(p1.factionName)));
						vm.txt_result(txt_result);
					}




				} else {
					// attack ai
					vm.allResources(true);
					vm.txt_result(_i('Remove all resources of the territory.'));
				}




			}
		}
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: ATTACK WORKERS RESOURCES *****************************/
/* VIEW: ATTACK WORKERS RESOURCES *****************************/
viewModelList.push(function () {
	var vm = {
		/*-----------------------*/
		viewName: 'view_attack_war_resources',
		/*-----------------------*/
		current: ko.observable(false),

		// draw
		workerPoints: SVG.worker.points,
		mechPoints: SVG.mech.points,

		// texts
		title_1: ko.observable(''),
		icon_1: ko.observable('player-icon-unit'),
		playerName_1: ko.observable(''),
		playerIcon_1: ko.observable(''),
		title_2: ko.observable(''),
		icon_2: ko.observable('player-icon-unit'),
		playerName_2: ko.observable(''),
		playerIcon_2: ko.observable(''),
		txt_tit: _i('Combat!'),
		txt_attack: ko.observable(''),
		txt_result: ko.observable(''),
		txt_continue: _i('Continue'),
		resourceList: ko.observableArray(),
		resourceListVisible: ko.observable(false),
		allResources: ko.observable(false),

		selectedPlayer: ko.observable(null)
	};
	var hex_attack;

	vm.continueAction = function () {
		GAME.hexConflict = GAME.evaluateAttack();
		if (GAME.hexConflict.workers.length > 0) {
			// Attack workers
			goToView('view_attack_worker');
		} else {
			if (GAME.hexConflict.war) {
				// War
				goToView('view_war');
			} else {
				var hexEncounter = GAME.evaluateEncounter();
				if (hexEncounter) {
					// Encounter
					goToView('view_encounter');
				} else {
					if (!currentPlayer.ai) {
						//continue to human start
						goToView('view_human_start');
					} else {
						// continue to evaluate AI resources
					}
				}
			}
		}

	};

	currentView.subscribe(function (newValue) {
		vm.current(newValue === vm.viewName);
		if (GAME && newValue === vm.viewName) {
			var p1, p2, num_of_Worker = 0;
			hex_attack = GAME.hexConflict.war;
			if (hex_attack) {

				p1 = GAME.getPlayerByFaction(hex_attack.attack.faction);
				p2 = GAME.getPlayerByFaction(hex_attack.faction);
				vm.title_1(_i(capitalize(p1.factionName)));
				vm.icon_1('player-icon-unit ' + p1.factionName);
				vm.playerName_1(_i(p1.name));
				vm.playerIcon_1(p1.icon);
				vm.title_2(_i(capitalize(p2.factionName)));
				vm.icon_2('player-icon-unit ' + p2.factionName);
				vm.playerName_2(_i(p2.name));
				vm.playerIcon_2(p2.icon);

				var winner = hex_attack.attack.faction === hex_attack.winner ? p1 : p2,
					loser = hex_attack.attack.faction === hex_attack.winner ? p2 : p1,
					winner_p = hex_attack.attack.faction === hex_attack.winner ? 'p1' : 'p2';				
				vm.selectedPlayer(winner_p);

				// p1 = GAME.getPlayerByFaction(hex_attack.attack.faction);
				// p2 = GAME.getPlayerByFaction(hex_attack.faction);

				// vm.title_1(_i(capitalize(p1.factionName)));
				// vm.icon_1('player-icon-unit ' + p1.factionName);
				// vm.playerName_1(_i(p1.name));
				// vm.playerIcon_1(p1.icon);
				// vm.title_2(_i(capitalize(p2.factionName)));
				// vm.icon_2('player-icon-unit ' + p2.factionName);
				// vm.playerName_2(_i(p2.name));
				// vm.playerIcon_2(p2.icon);

				// var textAttack = num_of_Worker === 1 ? 'attack % worker' : 'attack % workers',
				// 	i_textAttack = _i(textAttack);
				// vm.txt_attack(i_textAttack.replace('%', num_of_Worker));

				if (!currentPlayer.ai) {
					// attack human

					if (p2.ai) {
						// vs. ai

						if(winner.factionName === currentPlayer.factionName){	

							vm.allResources(false);
							var typeRes = hex_attack.type;

							var required = typeRes === 'iron' || typeRes === 'farm' || typeRes === 'oil' || typeRes === 'wood';

							if (GAME.aiResources > 0 && required) {

								var txt_result = _i('Put %num %type in the territory.');

								txt_result = txt_result.replace('%num', GAME.aiResources);
								txt_result = txt_result.replace('%type', typeRes);

								vm.txt_result(txt_result);

								var list = [],
									counter = GAME.aiResources;

								while (counter > 0) {
									list.push({
										type: typeRes
									});
									counter--;
								}
								vm.resourceListVisible(true);
								vm.resourceList(list);

							} else {
								vm.resourceListVisible(false);
								vm.txt_result(_i('There are not resources in the territory.'));
							}
						} else {
							vm.resourceListVisible(false);
							vm.allResources(false);
							var txt_result = _i('%faction does not obtain any resource in the territory.');
							txt_result = txt_result.replace('%faction', _i(capitalize(currentPlayer.factionName)));
							vm.txt_result(txt_result);
						}


					} else {
						// vs. human
						vm.resourceListVisible(false);
						if(winner.factionName === currentPlayer.factionName){							
							vm.allResources(true);
							var txt_result = _i('%faction obtain all resources in the territory.');
							txt_result = txt_result.replace('%faction', _i(capitalize(currentPlayer.factionName)));
							vm.txt_result(txt_result);
						}else{
							vm.allResources(false);
							var txt_result = _i('%faction does not obtain any resource in the territory.');
							txt_result = txt_result.replace('%faction', _i(capitalize(currentPlayer.factionName)));
							vm.txt_result(txt_result);
						}
					}




				} else {
					// attack ai
					vm.resourceListVisible(false);
					if(winner.factionName === currentPlayer.factionName){	
						vm.allResources(true);
						vm.txt_result(_i('Remove all resources of the territory.'));
					}else{
						vm.allResources(false);
						var txt_result = _i('%faction does not obtain any resource in the territory.');
						txt_result = txt_result.replace('%faction', _i(capitalize(currentPlayer.factionName)));
						vm.txt_result(txt_result);
					}
				}




			}
		}
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: ATTACK WORKERS RESOURCES *****************************/
/* VIEW: ENCOUNTER *****************************/
viewModelList.push(function () {
	var vm = {
		/*-----------------------*/
		viewName: 'view_encounter',
		/*-----------------------*/
		current: ko.observable(false),

		// draw
		mechPoints: SVG.character.points,

		// texts
		title_1: ko.observable(''),
		icon_1: ko.observable('player-icon-unit big'),
		playerName_1: ko.observable(''),
		playerIcon_1: ko.observable(''),
		
		txt_tit: _i('Encounter'),
		txt_result: ko.observable('Remove the encounter token from the territory'),
		txt_continue: _i('Continue')
	};

	vm.continueAction = function () {
		if (GAME.hexConflict.workers.length > 0) {
			// Attack workers
			goToView('view_attack_worker');
		} else {
			if (GAME.hexConflict.war) {
				// War
				goToView('view_war');
			} else {
				if (!currentPlayer.ai) {
					//continue to human start
					goToView('view_human_start');
				} else {
					// continue to evaluate AI resources
				}				
			}
		}
	};

	currentView.subscribe(function (newValue) {
		vm.current(newValue === vm.viewName);
		if (GAME && newValue === vm.viewName) {
			var p1, hex = GAME.evaluateEncounter();

			if (hex) {
				p1 = GAME.getPlayerByFaction(hex.faction);
				vm.title_1(_i(capitalize(p1.factionName)));
				vm.icon_1('player-icon-unit big ' + p1.factionName);
				vm.playerName_1(_i(p1.name));
				vm.playerIcon_1(p1.icon);

				GAME.MAP[hex.num].encounter = false;
			}
		}
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: ENCOUNTER *****************************/
/* VIEW: WAR *****************************/
viewModelList.push(function() {

	var vm = {
		/*-----------------------*/
		viewName: 'view_war',
		/*-----------------------*/
		current: ko.observable(false),
		// draw
		mechPoints: SVG.mech.points,
		// texts
		title_1: ko.observable(''),
		icon_1: ko.observable('player-icon-unit'),
		playerName_1: ko.observable(''),
		playerIcon_1: ko.observable(''),
		title_2: ko.observable(''),
		icon_2: ko.observable('player-icon-unit'),
		playerName_2: ko.observable(''),
		playerIcon_2: ko.observable(''),		
		txt_continue: _i('Continue'),
		txt_tit: _i('Combat!')
	};

	var p1,p2,hex_attack = null;

	vm.continueAction = function(){
		if(hex_attack){
			if(p1.ai && p2.ai){
				// between AIs
				goToView('view_war_bet_ai');
				//log('between AIsssss');
				//var a = GAME.combatBetweenAIs(p1,p2);
				//console.log(a);
			}else{
				if(!p1.ai && !p2.ai){
					// between Humans
					goToView('view_war_bet_humans');
				}else{
					// Human vs AI
					log('Human vs AI');
				}
			}
		}
	};

	currentView.subscribe(function(newValue) {
		vm.current(newValue === vm.viewName);
		if (GAME && newValue === vm.viewName) {
			//GAME.hexConflict = GAME.evaluateAttack();
			console.log('GAME.hexConflict',GAME.hexConflict);
			hex_attack = GAME.hexConflict.war;
			if(hex_attack){
				p1 = GAME.getPlayerByFaction(hex_attack.attack.faction);
				p2 = GAME.getPlayerByFaction(hex_attack.faction);

				vm.title_1(_i(capitalize(p1.factionName)));
				vm.icon_1('player-icon-unit ' + p1.factionName);
				vm.playerName_1(_i(p1.name));
				vm.playerIcon_1(p1.icon);
				vm.title_2(_i(capitalize(p2.factionName)));
				vm.icon_2('player-icon-unit ' + p2.factionName);
				vm.playerName_2(_i(p2.name));
				vm.playerIcon_2(p2.icon);
			}
		}
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* VIEW: BETWEEN HUMANS *****************************/
viewModelList.push(function () {
	var vm = {
		/*-----------------------*/
		viewName: 'view_war_bet_humans',
		/*-----------------------*/
		current: ko.observable(false),
		// draw
		mechPoints: SVG.mech.points,
		// texts
		title_1: ko.observable(''),
		icon_1: ko.observable('player-icon-unit'),
		playerName_1: ko.observable(''),
		playerIcon_1: ko.observable(''),
		title_2: ko.observable(''),
		icon_2: ko.observable('player-icon-unit'),
		playerName_2: ko.observable(''),
		playerIcon_2: ko.observable(''),		
		txt_continue: _i('Continue'),
		txt_tit: _i('Combat!'),
		txt_subtit: _i('between humans'),
		txt_cop: _i('And the WINNER is:'),
		txt_help: _i('Select the winning faction of the combat.'),
		selectedPlayer: ko.observable(null)
	};

	var p1, p2, hex_attack = null;

	vm.selectP1 = function () {
		vm.selectedPlayer('p1');
	};
	vm.selectP2 = function () {
		vm.selectedPlayer('p2');
	};

	vm.continueAction = function () {
		var f_win = vm.selectedPlayer();
		if (f_win) {
			var fact = f_win === 'p1' ? p1.factionName : p2.factionName;
			hex_attack.winner = fact;
			goToView('view_war_results');
		} else {
			showAlert(_i('Please, select the winning faction of the combat.'));
		}
	};

	currentView.subscribe(function (newValue) {
		vm.current(newValue === vm.viewName);
		if (GAME && newValue === vm.viewName) {
			vm.selectedPlayer(null);
			hex_attack = GAME.hexConflict.war;
			if (hex_attack) {
				p1 = GAME.getPlayerByFaction(hex_attack.attack.faction);
				p2 = GAME.getPlayerByFaction(hex_attack.faction);
				vm.title_1(_i(capitalize(p1.factionName)));
				vm.icon_1('player-icon-unit ' + p1.factionName);
				vm.playerName_1(_i(p1.name));
				vm.playerIcon_1(p1.icon);
				vm.title_2(_i(capitalize(p2.factionName)));
				vm.icon_2('player-icon-unit ' + p2.factionName);
				vm.playerName_2(_i(p2.name));
				vm.playerIcon_2(p2.icon);
			}
		}
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: BETWEEN HUMANS *****************************/
/* VIEW: BETWEEN AIs *****************************/
viewModelList.push(function () {
	var vm = {
		/*-----------------------*/
		viewName: 'view_war_bet_ai',
		/*-----------------------*/
		current: ko.observable(false),
		// draw
		mechPoints: SVG.mech.points,
		// texts
		title_1: ko.observable(''),
		icon_1: ko.observable('player-icon-unit'),
		playerName_1: ko.observable(''),
		playerIcon_1: ko.observable(''),
		title_2: ko.observable(''),
		icon_2: ko.observable('player-icon-unit'),
		playerName_2: ko.observable(''),
		playerIcon_2: ko.observable(''),		
		txt_continue: _i('Continue'),
		txt_tit: _i('Combat!'),
		txt_subtit: _i('between automas'),
		txt_cop: _i('And the WINNER is:'),
		txt_attackWith: _i('Attack with'),
		txt_help: ko.observable(''),
		txt_pow1: ko.observable(0),
		txt_pow2: ko.observable(0),
		selectedPlayer: ko.observable(null),
		step:ko.observable(1),
	};

	var p1, p2, hex_attack, results = null;

	vm.selectP1 = function () {
		vm.selectedPlayer('p1');
	};
	vm.selectP2 = function () {
		vm.selectedPlayer('p2');
	};

	vm.continueAction = function () {
		if(vm.step() === 1){
			vm.step(2);
			vm.selectedPlayer(results.player1.winner ? 'p1':'p2');
			var txtHelp = _i('$faction1 must reduce his power in %val1 (to %val1c), and $faction2 must reduce his power in %val2 (to %val2c).');
			txtHelp = txtHelp.replace('$faction1', capitalize(p1.factionName));
			txtHelp = txtHelp.replace('%val1', results.player1.reduce);
			txtHelp = txtHelp.replace('%val1c', p1.power);
			txtHelp = txtHelp.replace('$faction2', capitalize(p2.factionName));
			txtHelp = txtHelp.replace('%val2', results.player2.reduce);
			txtHelp = txtHelp.replace('%val2c', p2.power);
			vm.txt_help(txtHelp);

		}else{
			var f_win = vm.selectedPlayer();
			var fact = f_win === 'p1' ? p1.factionName : p2.factionName;
			
			hex_attack.winner = fact;
			goToView('view_war_results');
		}
	};

	currentView.subscribe(function (newValue) {
		vm.current(newValue === vm.viewName);
		if (GAME && newValue === vm.viewName) {
			vm.selectedPlayer(null);
			vm.step(1);
			hex_attack = GAME.hexConflict.war;
			if (hex_attack) {
				p1 = GAME.getPlayerByFaction(hex_attack.attack.faction);
				p2 = GAME.getPlayerByFaction(hex_attack.faction);
				vm.title_1(_i(capitalize(p1.factionName)));
				vm.icon_1('player-icon-unit ' + p1.factionName);
				vm.playerName_1(_i(p1.name));
				vm.playerIcon_1(p1.icon);
				vm.title_2(_i(capitalize(p2.factionName)));
				vm.icon_2('player-icon-unit ' + p2.factionName);
				vm.playerName_2(_i(p2.name));
				vm.playerIcon_2(p2.icon);

				results = GAME.combatBetweenAIs(p1,p2);

				vm.txt_pow1(results.player1.reduce);
				vm.txt_pow2(results.player2.reduce);
			}
		}
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: BETWEEN AIs *****************************/
/* VIEW: WAR RESULTS *****************************/
viewModelList.push(function () {
	var vm = {
		/*-----------------------*/
		viewName: 'view_war_results',
		/*-----------------------*/

		current: ko.observable(false),
		// draw
		mechPoints: SVG.mech.points,
		// texts
		title_1: ko.observable(''),
		icon_1: ko.observable('player-icon-unit'),
		playerName_1: ko.observable(''),
		playerIcon_1: ko.observable(''),
		title_2: ko.observable(''),
		icon_2: ko.observable('player-icon-unit'),
		playerName_2: ko.observable(''),
		playerIcon_2: ko.observable(''),		
		txt_continue: _i('Continue'),
		txt_tit: _i('Combat!'),
		txt_cop: _i('Results of:'),
		txt_help1: ko.observable(''),
		txt_help2: ko.observable(''),

		selectedPlayer: ko.observable(null)
	};

	var p1, p2, hex_attack, winner, loser = null;
	vm.continueAction = function () {
		//debugger;
		// CONTINUE
		// GAME.hexConflict = GAME.evaluateAttack();		
		// if (GAME.hexConflict.war) {
		// 	goToView('view_war');
		// } else {
		// 	var hexEncounter = GAME.evaluateEncounter();
		// 	if (hexEncounter) {
		// 		// Encounter
		// 		goToView('view_encounter');
		// 	} else {
		// 		if(!currentPlayer.ai){
		// 			//continue to human start
		// 			goToView('view_human_start');
		// 		}else{
		// 			// continue to evaluate AI resources
		// 		}
		// 	}
		// }
		goToView('view_attack_war_resources');
	};

	currentView.subscribe(function (newValue) {
		vm.current(newValue === vm.viewName);
		if (GAME && newValue === vm.viewName) {
			//vm.selectedPlayer(null);
			hex_attack = GAME.hexConflict.war;
			if (hex_attack) {
				p1 = GAME.getPlayerByFaction(hex_attack.attack.faction);
				p2 = GAME.getPlayerByFaction(hex_attack.faction);
				vm.title_1(_i(capitalize(p1.factionName)));
				vm.icon_1('player-icon-unit ' + p1.factionName);
				vm.playerName_1(_i(p1.name));
				vm.playerIcon_1(p1.icon);
				vm.title_2(_i(capitalize(p2.factionName)));
				vm.icon_2('player-icon-unit ' + p2.factionName);
				vm.playerName_2(_i(p2.name));
				vm.playerIcon_2(p2.icon);
				
				winner = hex_attack.attack.faction === hex_attack.winner ? p1 : p2;
				loser = hex_attack.attack.faction === hex_attack.winner ? p2 : p1;
				//debugger;
				var winner_p = hex_attack.attack.faction === hex_attack.winner ? 'p1' : 'p2';				
				vm.selectedPlayer(winner_p);
				var textHelp1 = _i('$faction, the losing faction, must retreat all of their units (mechs, characters, and workers) from the combat territory to their home base.');
				textHelp1 = textHelp1.replace('$faction', capitalize(loser.factionName));
				vm.txt_help1(textHelp1);
				
				winner.board.starsByWar--;
				if(winner.board.starsByWar >= 0){
					winner.board.stars--;
					var textHelp2 = _i('$faction, the winner faction, places 1 star token in the combat space of the Triumph Track.');
					textHelp2 = textHelp2.replace('$faction', capitalize(winner.factionName));
					vm.txt_help2(textHelp2);
				}else{
					vm.txt_help2('');
				}				
				
				var baseIndex = GAME.getBaseMapIndex(loser.factionName);
				
				if(winner_p === 'p1'){
					// if attack wins
					// send units defenders to base
					GAME.MAP[baseIndex].people.worker += hex_attack.people.worker;
					GAME.MAP[baseIndex].people.mech += hex_attack.people.mech;
					GAME.MAP[baseIndex].people.character += hex_attack.people.character;

					// Renew faction, mech and/or character
					GAME.MAP[hex_attack.num].faction = hex_attack.attack.faction;
					GAME.MAP[hex_attack.num].people.worker = 0;
					GAME.MAP[hex_attack.num].people.mech = hex_attack.attack.mech || 0;
					GAME.MAP[hex_attack.num].people.character = hex_attack.attack.character || 0;
				}else{
					// if defend wins
					// send units attackers to base
					GAME.MAP[baseIndex].people.mech += hex_attack.attack.mech || 0;
					GAME.MAP[baseIndex].people.character += hex_attack.attack.character || 0;
				}

				// Reset attack
				GAME.MAP[hex_attack.num].attack = null;
				
			}
		}
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: WAR RESULTS *****************************/
/* VIEW: AI RESOURCES *****************************/
viewModelList.push(function () {
	var vm = {
		/*-----------------------*/
		viewName: 'view_ai_resources',
		/*-----------------------*/
		current: ko.observable(false),
		// texts
		txt_title: _i('Resources for'),
		txt_gain: ko.observable(''),
		txt_continue: _i('Continue'),
		title: ko.observable(''),
		icon: ko.observable(''),
		playerName: ko.observable(''),
		playerIcon: ko.observable(''),

		worker: ko.observable(0),
		mech: ko.observable(0),
		power: ko.observable(0),
		money: ko.observable(0),
		card: ko.observable(0),

		txt_1: ko.observable(''),
		txt_2: ko.observable(''),
		txt_3: ko.observable('')
	};

	vm.continueAction = function () {		
		if(currentPlayer.power >= 16 && currentPlayer.board.starsByPower > 0){
			// Gain a Star for power
			// Goto put star
		}else{
			if(AI_actions.recruit){
				// Goto AI recruit
				goToView('view_ai_recruit');
			}else{
				var putAIStar = GAME.evaluateFinishTurnAI(currentPlayer);
				if(putAIStar){
					// Goto put star
				}else{
					GAME.advancePlayer();
					goToView('view_start_turn');
				}
			}
		}
	};

	currentView.subscribe(function (newValue) {
		vm.current(newValue === vm.viewName);
		if (GAME && newValue === vm.viewName) {
			currentPlayer = GAME.getCurrentPlayer();

			vm.title(_i(capitalize(currentPlayer.factionName)));
			vm.icon('images/factions/' + currentPlayer.factionName + '.png');
			
			vm.playerName(_i(currentPlayer.name));
			vm.playerIcon(currentPlayer.icon);

			var txt = _i('%faction gets:');

			txt = txt.replace('%faction',capitalize(_i(currentPlayer.factionName)));

			vm.txt_gain(txt);
			
			
			var textArray = [];

			for(var a in AI_actions.gain){
				var n = AI_actions.gain[a];
				vm[a](n);
				if(n > 0){
					switch(a){
						case 'worker':
							var txt = _i("Deploy %num worker to the %faction's home base.");
							txt = n > 1 ? txt.replace(_i('worker'),_i('workers')) : txt;
							txt = txt.replace('%num',n);
							txt = txt.replace('%faction',capitalize(_i(currentPlayer.factionName)));
							textArray.push({
								order:4,
								txt:txt
							});
							break;
						case 'mech':
							var txt = _i("Deploy %num mech to the %faction's home base.");
							txt = n > 1 ? txt.replace(_i('mech'),_i('mechs')) : txt;
							txt = txt.replace('%num',n);
							txt = txt.replace('%faction',capitalize(_i(currentPlayer.factionName)));
							textArray.push({
								order:5,
								txt:txt
							});
							break;
						case 'money':
							var txt = _i("%faction obtain %num of money.");
							txt = txt.replace('%num',n);
							txt = txt.replace('%faction',capitalize(_i(currentPlayer.factionName)));
							textArray.push({
								order:1,
								txt:txt
							});
							break;
						case 'card':
							var txt = _i("%faction obtain %num card.");
							txt = n > 1 ? txt.replace(_i('card'),_i('cards')) : txt;
							txt = txt.replace('%num',n);
							txt = txt.replace('%faction',capitalize(_i(currentPlayer.factionName)));
							textArray.push({
								order:3,
								txt:txt
							});
							break;
						case 'power':
							var txt = _i("%faction increases his power in %num.");
							txt = txt.replace('%num',n);
							txt = txt.replace('%faction',capitalize(_i(currentPlayer.factionName)));
							textArray.push({
								order:2,
								txt:txt
							});
							break;
						default:
							//
					}
				}
			}

			textArray.sort(function(a,b){
				return a.order < b.order ? -1 : 1;
			});

			for(var k = 0; k < textArray.length; k++){
				if(k < 3){
					vm['txt_'+(k+1)](textArray[k].txt);
				}
			}

			// Add to map
			currentPlayer.board.worker -= AI_actions.gain.worker;
			currentPlayer.board.mech -= AI_actions.gain.mech;
			var baseMapNum = GAME.getBaseMapIndex(currentPlayer.factionName);
			GAME.MAP[baseMapNum].people.worker += AI_actions.gain.worker;
			GAME.MAP[baseMapNum].people.mech += AI_actions.gain.mech;

			// Add power
			currentPlayer.power += AI_actions.gain.power;

			// Add money
			currentPlayer.money += AI_actions.gain.money;

			// Add cards
			currentPlayer.cards += AI_actions.gain.card;
		}
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: AI RESOURCES *****************************/
/* VIEW: AI RECRUIT *****************************/
viewModelList.push(function () {
	var vm = {
		/*-----------------------*/
		viewName: 'view_ai_recruit',
		/*-----------------------*/
		current: ko.observable(false),
		// texts
		txt_title: _i('Gain for recruit'),
		txt_gain: ko.observable(''),
		txt_continue: _i('Continue'),
		title: ko.observable(''),
		icon: ko.observable(''),
		playerName: ko.observable(''),
		playerIcon: ko.observable(''),

		worker: ko.observable(0),
		mech: ko.observable(0),
		power: ko.observable(0),
		money: ko.observable(0),
		card: ko.observable(0),

		txt_1: ko.observable(''),
		iconClass: ko.observable(''),
		iconSrc: ko.observable('')
	};

	vm.continueAction = function () {		
		var putAIStar = GAME.evaluateFinishTurnAI(currentPlayer);
		if(putAIStar){
			// Goto put star
		}else{
			GAME.advancePlayer();
			goToView('view_start_turn');
		}		
	};

	currentView.subscribe(function (newValue) {
		vm.current(newValue === vm.viewName);
		if (GAME && newValue === vm.viewName) {
			currentPlayer = GAME.getCurrentPlayer();

			vm.title(_i(capitalize(currentPlayer.factionName)));
			vm.icon('images/factions/' + currentPlayer.factionName + '.png');
			
			vm.playerName(_i(currentPlayer.name));
			vm.playerIcon(currentPlayer.icon);

			var typeRecruit = AI_actions.recruit;
			var images = {
				'popularity':'popularity',
				'card':'card-power',
				'power':'power',
				'money':'money',
			};

			vm.iconClass('item for-'+typeRecruit);
			vm.iconSrc('images/'+images[typeRecruit]+'.svg');
			
			// card
			// power
			// money
			// popularity
			var txt = _i('if you have enlisted the %type recruit, then you gain the %type recruit bonus.');
			txt = txt.replace(new RegExp('%type', 'g'),typeRecruit);
			vm.txt_1(txt);
	
		}
	});
	ko.applyBindings(vm, document.getElementById(vm.viewName));
	return vm;
});
/* end VIEW: AI RECRUIT *****************************/
	function force(vn){
		bindAllModels();
		presentationVM.current(false);
		goToView(vn);
	}
	
	GAME = createGame([2,0,1]);
//
force('view_start_turn');
//force('view_map');


})();
/* END UI *******************************************/
/* INIT *****************************/
})();
